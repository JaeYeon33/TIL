## 자바 ORM 표준 JPA 프로그래밍

![https://camo.githubusercontent.com/3073829860a866037e0ca12f244a9eb5462e4cfa/687474703a2f2f696d6167652e6b796f626f626f6f6b2e636f2e6b722f696d616765732f626f6f6b2f786c617267652f3333302f78393738383936303737373333302e6a7067](https://camo.githubusercontent.com/3073829860a866037e0ca12f244a9eb5462e4cfa/687474703a2f2f696d6167652e6b796f626f626f6f6b2e636f2e6b722f696d616765732f626f6f6b2f786c617267652f3333302f78393738383936303737373333302e6a7067)


## 목차
- 영속성 관리 - 내부 동작 방식
  - 영속성 컨텍스트
  - 영속성 컨텍스트의 이점
  - 플러시 (flush)
  - 준영속 상태
- 엔티티 매핑
  - 엔티티 매핑 소개
  - JPA로 데이터베이스 스키마를 자동 생성하는 방법
  - 객체와 테이블 매핑
  - 데이터베이스 스키마 자동 생성
  - 필드와 컬럼 매핑
  - 기본 키 매핑
- 연관관계 매핑 기초
  - 연관관계의 필요성
  - 객체를 테이블에 맞춰 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다.
  - 양방향 연관관계와 연관관계 주인1 - 기본
    - 연관관계의 주인과 mappedBy
    - 객체와 테이블이 관계를 맺는 차이란?
    - 양방향 관계란
    - 외래키 관리
    - 연관관계의 주인(Owner)
    - 누구를 주인으로 설정?
  - 양방향 연관관계와 연관관계 주인1 - 주의점
    - 양방향 매핑시 가장 많이 하는 실수
    - 양방향 매핑시 무한 루프를 조심! (순환 참조)
    - 양방향 매핑 정리
- 다양한 연관관계 매핑
  - 연관관계 매핑시 고려사항 3가지
  - 다대일 [N:1]
    - 다대일 [N:1] 단방향
    - 다대일 양방향
  - 일대다 [1:N]
    - 일(One)이 연관관계의 주인
    - 권장하지 않는 이유
    - 일대다 [1:N] 양방향
  - 일대일 [1:1]
  - 다대다 [N:M]
    - 다대다 매핑의 한계
    - 다대다 한계 극복
- 고급 매핑
  - 상속관계 매핑
    - 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현 방법
    - 주요 어노테이션
  - @MappedSuperclass
- 프록시와 연관관계 관리
  - 프록시
  - 즉시로딩과 지연로딩
    - 지연 로딩
    - 즉시 로딩
    - 프록시와 즉시로딩 주의
    - N+1의 해결책
    - 지연 로딩 활용
    - 지연 로딩 활용 - 실무
  - 영속성 전이 (CASCADE)와 고아 객체
    - 영속성 전이 (CASCADE)는 언제 써야 할까?
- 값 타입
  - 기본값 타입
  - 임베디드 타입
    - 임베디드 타입을 통해 객체를 분리하더라도 테이블은 하나만 매핑
    - Member안에 동일한 임베디드 타입이 있다면 어떻게 될까?
    - @AttributeOverride를 사용해서 컬럼명 속성을 재정의
  - 값 타입과 불변 객체
    - 값 타입은 복잡한 객체 세상을 조금이라도 단순화 하려고 만든 개념
    - 값(인스턴스)을 복사해서 사용
    - 누군가 실수로 값 복사가 아닌 기존 값을 넣는다면 막을 수 있는가?
  - 값 타입의 비교
  - 값 타입 컬렉션
    - 식별자가 필요, 지속해서 값을 추적, 변경해야 한다면 값 타입이 아닌 엔티티
- 객체지향 쿼리 언어1 - 기본 문법
  - 소개
  - 기본 문법과 쿼리 API
  - 프로젝션(SELECT)
    - 묵시적 조인과 명시적 조인
    - 임베디드 타입 프로젝션
    - 스칼라 타입 프로젝션 / 여러 값 조회
  - 페이징
  - 조인
  - 서브쿼리
  - JPQL 타입표현과 기타식
  - 조건식 (CASE 등등)
    - 기본 CASE 식
    - 단순 CASE 식
  - JPQL 함수
- 객체지향 쿼리 언어2 - 중급 문법
  - 경로 표현식
    - .(점)을 찍어 객체 그래프를 탐색하는 것
    - 실무에서는 명시적 조인을 사용
    - 조인은 SQL 튜닝에 중요 포인트
    - 묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려움
  - JPQL - 페치 조인(fetchJoin)
    - 실무에서 자주 사용
    - fetch Join을 사용해서 가져왔을 경우 사이즈는 어떻게 나올 것인가
    - 다대일 [N:1]은 뻥튀기 되지 않는다.
    - 해결 방안
  - 다형성 쿼리
  - 엔티티 직접 사용
    - 기본 키 값
    - 외래 키 값
  - Named 쿼리 
    - SpringData JPA를 사용하면 NamedQuery를 이미 사용
  - 벌크 연산
    - 엔티티 직접 사용 - 외래 키 값
  - JPQL - Naemd 쿼리
    - Named 쿼리 - 정적 쿼리
    - Named 쿼리 - 어노테이션
    - Named 쿼리 - XML에 정의
    - Named 쿼라 환경에 따른 설정
  - JQPL - 벌크 연산
    - 벌크 연산
    - 벌크 연산 예제
    - 벌크 연산 주의