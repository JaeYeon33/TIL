## 1. 변수(Variable)

---

### 1) 변수(Variable)란?

프로그래밍언어에서 변수(variable)란, 값을 저장할 수 있는 메모리상의 공간을 의미한다.

```
"변수란, 단 하나의 값을 저장할 수 있는 메모리 공간"
```

하나의 변수에 단 하나의 값만 저장할 수 있으므로, 새로운 값을 저장하면 기존의 값은 사라진다.

<br>

### 2) 변수의 선언과 초기화

변수를 사용하려면 먼저 변수를 선언해야하는데, 변수의 선언방법은 다음과 같다.

```java
int age; // age 라는 이름의 변수를 선언

// int : 변수타입
// age : 변수이름
```

`변수타임` : 변수에 저장될 값이 어떤 타입(Type)인지를 지정하는 것이다.

`변수이름` : 말 그대로 변수에 붙인 이름이다. 변수는 '값을 저장할 수 있는 메모리 공간' 이므로 변수의 이름은 메모리 공간에 이름을 붙여주는 것이다. 변수를 선언하면, 메모리의 빈 공간에 `변수타입` 에 알맞은 크기의 저장공간이 확보되고, 앞으로 이 저장공간은 `변수이름` 을 통해 사용할 수 있게 된다.

<br>

**변수의 초기화**

변수를 선언한 이후부터는변수를 사용할 수 있으나, 그 전에 반드시 변수를 초기화(initialization)해야 한다. 메모리는 여러 프로그램이 공유하는 자원이므로 전에 다른 프로그램에 의해 저장된 '알 수 없는 값(쓰레기값, Garbage Value)'이 남아있을 수 있기 때문이다.

```java
int age = 25; // 변수 age를 선언하고 25로 초기화 한다.
```

<br>

변수는 한 줄에 하나씩 선언하는 것이 보통이지만, 타입이 같은 경우 콤마 `,`를 구분자로 한 줄에 선언하기도 한다.

```java
int a;
int b;
int x = 0;
int y = 0;
```

```java
int a, b;
int x = 0, y = 0;
```

<br>

변수의 종류에 따라 변수의 초기화를 생략할 수 있는 경우도 있지만, 변수는 사용되기 전에 적절한 값으로 초기화 하는 것이 좋다.

```java
"변수의 초기화란, 변수를 사용하기 전에 처음으로 값을 저장하는 것"
```

```java
package ch2;

class VarEx1 {
    public static void main(String[] args) {
        int year = 0;
        int age = 14;

        System.out.println(year);
        System.out.println(age);

        year = age + 2000; // 변수 age의 값에 2000을 더해서 변수 year에 저장
        age = age + 1;     // 변수 age에 저장된 값을 1증가시킨다.

        System.out.println(year);
        System.out.println(age);
    }
}
```

```java
0
14
2014
15
```

<br>

**두 변수의 값 교환하기**

**변수 y에 저장된 값을 변수 x에 저장**

```java
x = y; 

// x = 10, y = 20;
// x = 20, y = 20;
```

<br>

**변수 x에 저장된 값을 변수 y에 저장**

```java
y = x;

// y = 20, x = 20
// y = 20, x = 20
```

첫 번째 단계에서 y의 값을 x에 저장할 때, 이미 x의 값이 없어졌기 때문에 x의 값을 y에 저장해도 소용이 없는 것이다.

다음과 같이 변수를 하나 더 선언해서 x의 값을 위한 임시 저장소로 사용하면 된다.

```java
int x = 10;
int y = 20;
int tmp; // x값을 임시로 저장할 변수를 선언
```

<br>

**변수 x에 저장된 값을 변수 tmp에 저장**

```java
tmp = x;

// x = 10, y = 20, tmp = 10
// x = 10, y = 20, tmp = 10
```

<br>

**변수 y에 저장된 값을 변수 x에 저장**

```java
x = y;

// x = 10, y = 20, tmp = 10
// x = 20, y = 20, tmp = 10
```

<br>

**변수 tmp에 저장된 값을 변수 y에 저장**

```java
y = tmp;

// x = 20, y = 20, tmp = 10
// x = 20, y = 10, tmp = 10
```

<br>

두 변수의 값을 교환하는 것은 마치 두 컵에 담긴 내용물을 바꾸려면 컵이 하나 더 필요한 것과 같다.

```java
package ch2;

class VarEx2 {
    public static void main(String[] args) {
        int x = 10, y = 20;
        int tmp = 0;

        System.out.println("x: " + x + " y: " + y);
        tmp = x;
        x = y;
        y = tmp;

        System.out.println("x: " + x + " y: " + y);
    }
}
```

```java
x: 10 y: 20
x: 20 y: 10
```

<br>

<br>

### 3) 변수의 명명 규칙

'변수의 이름' 처럼 프로그래밍에서 사용하는 모든 이름을 '식별자(identifier)' 라고 하며, 식별자는 같은 영역 내에서 서로 구분(식별)될 수 있어야한다.

```
1. 대소문자가 구분되며 길이에 제한이 없다.
  - True와 true는 서로 다른 것으로 간주한다.
2. 예약어를 사용해서는 안 된다.
  - true는 예약어라서 사용할 수 없지만, True는 가능하다.
3. 숫자로 시작해서는 안 된다.
  - top10은 허용하지만, 7up은 허용되지 않는다.
4. 특수문자는 '_'와 '$'만을 허용한다.
  - $harp은 허용되지만, S#arp은 허용되지 않는다.
```

<br>

예약어는 키워드(keyword) 또는 '리져브드 워드(reserved word)'라고 하는데, 프로그래밍언어의 구문에 사용되는 단어를 뜻한다. 그래서 예약어는 클래스나 변수, 메서드의 이름(identifier)으로 사용할 수 없다.

<br>

그 외에 필수적인 것은 아니지만 자바 프로그래머들에게 권장하는 규칙들은 다음과 같다.

```
1. 클래스 이름의 첫 글자는 항상 대문자로 한다.
  - 변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다.
2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.
  - IastIndexOf, StringBuffer
3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 '_'로 구분한다.
  - PI, MAX_NUMBER
```

위의 규칙들은 반드시 지켜야 하는 것은 아니지만, 코드를 보다 이해하기 쉽게 하기 위한 자바 개발자들 사이의 암무적인 약속이다. 이 규칙을 따르지 않는다고 해서 문제가 되는것은 아니지만 가능하면 지키도록 노력하자.

만일 특별한 방식으로 식별자를 작성해야 한다면 `미리 규칙(Coding Convention)` 을 정해놓고 프로그램 전체에 일관되게 적용하는 것이 필요하다.

변수의 이름은 짧을수록 좋지만, 약간 길더라도 용도를 알기 쉽게 `의미있는 이름` 으로 하는 것이 바람직하다. 변수의 선언문에 주석으로 변수에 대한 정보를 주는 것도 좋은 생각이다.

<br>

```java
int curPos = 0;   // 현재 위치(current position)
int lastPos = -1; // 마지막 위치(last position)
```

<br>

<br>

<br>

## 2. 변수의 타입

---

우리가 주로 사용하는 값(data)의 종류(type)는 크게 `문자와 숫자` 로 나눌 수 있으며, 숫자는 다시 `정수와 실수` 로 나눌 수 있다.

이러한 값(data)의 종류(type)에 따라 값이 저장될 공간의 크기와 저장형식을 정의한 것이 자료형(data type)이다. 자료형에는 `문자형(char)` , `정수형(byte, short, int, long)` , `실수형(float, double)` 등이 있으며, 변수를 선언할 때는 저장하려는 값의 특성을 고려하여 가장 알맞은 자료형을 변수의 타입으로 선택하면 된다.

<br>

<br>

### 기본형과 참조형

```
기본형(Primitive Type)
	- 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)
		계산을 위한 실제 값을 저장한다. 모두 8개

참조형(Reference Type)
	- 객체의 주소를 저장한다. 8개의 기본형을 제외한 나머지 타입.
```

참조형 변수(또는 참조변수)를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 참조변수의 타입이 된다. 그래서 새로운 클래스를 작성한다는 것은 새로운 참조형을 추가하는 셈이다.

참조변수를 선언하는 방법. 기본형 변수와 같이 변수이름 앞에 타입을 적어 주는데 참조변수의 타입은 클래스의 이름이다.

```
클래스이름 변수이름; // 변수의 타입이 기본형이 아닌 것들은 모두 참조변수이다.
```

<br>

다음은 Date 클래스 타입의 참조변수 today를 선언한 것이다. 참조변수는 null 또는 객체의 주소를 값으로 갖으며 참조변수의 초기화는 다음과 같이 한다.

```java
Date today = new Date(); // Date객체를 생성해서, 그 주소를 today에 저장
```

<br>

객체를 생성하는 연산가 new의 결과는 생성된 객체의 주소이다. 이 주소가 대입연산자 `=` 에 의해서 참조변수 today에 저장되는 것이다. 이제 참조변수 today를 통해서 생성된 객체를 사용할 수 있게 된다.

- 자료형(data type)과 타입(type)의 차이는 무엇인가?
⇒ 기본형은 저장할 값(data)의 종류에 따라 구분되므로 기본형의 종류를 얘기할 때는 '자료형(data type)' 이라는 용어를 쓴다. 그러나 참조형은 항상 '객체의 주소(4 byte 정수)'를 저장하므로 값(data)이 아닌, 객체의 종류에 의해 구분되므로 참조형 변수의 종류를 구분할 때는 '타입(type)' 이라는 용어를 사용한다. `타입이 자료형을 포함하는 보다 넓은 의미의 용어이므로 굳이 구분하지 않아도 된다.`

<br>

### 1) 기본형 (Primitive Type)

<br>

| 분류   | 타입                   | 용도                                                         |
| ------ | ---------------------- | ------------------------------------------------------------ |
| 논리형 | boolean                | true와 false 중 하나를 값으로 갖으며, 조건식과 논리적 계산에 사용된다. |
| 문자형 | char                   | 문자를 저장하는데 사용되며, 변수에 하나의 문자만 저장할 수 있다. |
| 정수형 | byte, short, int, long | 정수를 저장하는데 사용되며, 주로 Int가 사용된다. byte는 이진 데이터를 다룰 때 사용 |
| 실수형 | float, double          | 실수를 저장하는데 사용되며, 주로 double이 사용.              |

<br>

문자형인 char는 문자를 내부적으로 정수(유니코드)로 저장하기 때문에 정수형과 별반 다르지 않으며, 정수형 또는 실수형과 연산도 가능하다. 반면에 boolean은 다른 기본형과의 연산이 불가능하다. 즉, boolean을 제외한 나머지 7개의 기본형은 서로 연산과 변환이 가능하다.

정수는 가장 많이 사용되므로 타입을 4가지나 제공한다. 각 타입마다 저장할 수 있는 값의 범위가 다르지만, 일반적으로 int를 많이 사용한다. 왜냐하면, int는 CPU가 가장 효율적으로 처리할 수 있는 타입이기 때문이다. 효율적인 실행보다 메모리를 절약하려면, byte나 short를 선택하자.

![picture](https://github.com/JaeYeon33/TIL/blob/main/JAVA/image/Untitled%201.png?raw=true)

<br>

<br>

### 2) 상수와 리터럴 (Constant & Iteral)

'상수(Constant)'는 변수와 마찬자기로 '값을 저장할 수 있는 공간' 이지만, 변수와 달리 한번 값을 저장하면 다른 값으로 변경할 수 없다. 상수를 선언하는 방법은 변수와 동일하며, 단지 변수의 타입 앞에 키워드 `final` 을 붙여주기만 하면 된다.

```java
final int MAX_SPEED = 10; // 상수 MAX_SPEED를 선언 & 초기화
```

<br>

그리고 상수는 반드시 선언과 동시에 초기화해야 하며, 그 후 부터는 상수의 값을 변경하는 것이 허용하지 않는다.

```java
final int MAX_SPEED;       // 에러. 상수는 선언과 동시에 초기화해야함
final int MAX_VALUE = 100; // OK. 선언과 동시에 초기화했음
MAX_VALUE = 200;           // 에러. 상수의 값은 변경할 수 없음
```

상수의 이름은 `모두 대문자로 하는 것이 암묵적인 관계` 이며, 여러 단어로 이루어져있는 경우 `_` 로 구분한다.

<br>

<br>

### 리터럴

원래 12, 123, 3.14, 'A'와 같은 값들이 `상수` 인데, 프로그래밍에서는 상수를 `값을 한 번 저장하면 변경할 수 없는 저장공간` 으로 정의하였기 때문에 이와 구분하기 위해 상수를 다른 이름으로 불러야만 했다. 그래서 상수 대신 리터럴이라는 용어를 사용한다. `리터럴은 단지 우리가 기존에 알고 있던 상수의 다른 이름일 뿐이다.`

```
변수(Variable) : 하나의 값을 저장하기 위한 공간
상수(Constant) : 값을 한번만 저장할 수 있는 공간
리터럴(literal) : 그 자체로 값의 의미하는 것
```

```java
int year = 2014;
final int MAX_VALUE = 100;

// 변수 : year
// 리터럴 : 2014, 100
// 상수 : MAX_VALUE
```

<br>

<br>

### 상수가 필요한 이유

```java
int triangleArea = (20 + 10) / 2; // 삼각형의 면적을 구하는 공식
int rectangleArea = 20 * 10;      // 사각형의 면적을 구하는 공식
```

```java
final int WIDTH = 20;  // 폭
final int HEIGHT = 10; // 넓이

int triangleArea = (WIDTH * HEIGHT) / 2; // 삼각형의 면적을 구하는 공식
int rectangleArea = WIDTH * HEIGHT;      // 사각형의 면적을 구하는 공식
```

이전 코드에 비해 면적을 구하는 공식의 의미가 명확해졌다. 그리고 다른 값으로 계산할 때도 여러 곳을 수정할 필요없이 상수의 초기화만 다른 값으로 해주면 된다.

<br>

<br>

### 리터럴의 타입과 점미사

변수에 타입이 있는 것처럼 리터럴에도 타입이 있다. 변수의 타입은 저장될 `값의 타입(리터럴의 타입)` 에 의해 결정되므로, 만일 리터럴에 타입이 없다면 변수의 타입도 필요없을 것이다.

| 종류   | 리터럴                       | 접미사 |
| ------ | ---------------------------- | ------ |
| 논리형 | flase, true                  | 없음   |
| 정수형 | 123, 0b0101, 077, 0xFF, 100L | L      |
| 실수형 | 3.14, 3.0e8, 1.41, 0x1, 0p-1 | f, d   |
| 문자형 | 'A', '1', '\n'               | 없음   |
| 문자열 | "ABC", "123", "A", "true"    | 없음   |



<br>

```java
int octNum = 010;  // 8진수 10, 10진수로 8
int hexNum = 0x10; // 16진수 10, 10진수로 16
int binNum = 0b10; // 2진수 10, 10진수로 2
```

<br>

JDK1.7부터 정수형 리터럴의 중간에 구분자 `_` 를 넣을 수 있게 되어서 큰 숫자를 편하게 읽을 수 있게 되었다.

```java
long big = 100_000_000_000L;       // long big = 100000000000L
long hex = 0xFFFF_FFFF_FFFF_FFFFL; // long hex = 0xFFFFFFFFFFFFFFFFL
```

<br>

<br>

실수형에서는 float 타입의 리터럴에 접미사 `f` 또는 `F` 를 붙이고, double 타입의 리터럴에는 접미사 `d` 또는 `D` 를 붙인다.

```java
float pi = 3.14f;     // 접미사 f 대신 F를 사용해도 된다.
double rate = 1.618d; // 접미사 d 대신 D를 사용해도 된다.
```

```java
float pi = 3.14;     // 에러. float 타입 변수에 double 타입 리터럴 저장하기
double rate = 1.618; // OK. 접미사 d는 생략할 수 있다.
```

리터럴의 접두사와 접미사는 대소문자를 구별하지 않으므로, 대문자와 소문자 중에서 어떤 것을 사용해도 상관 없지만 대문자로 사용하는 것이 좋다.

<br>

| 자료형 | 실수형 리터럴 | 다른 형태의 동등한 표현 |
| ------ | ------------- | ----------------------- |
| double | 10.           | 10.0                    |
| double | .10           | 0.10                    |
| float  | 10f           | 10.0f                   |
| float  | 3.14e3f       | 3140.0f                 |
| double | 1el           | 10.0                    |
| double | 1e-3          | 0.001                   |

<br>

<br>

### 타입의 불일치

리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만, 타입이 달라도 저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다.

```java
int i = 'A';      // OK. 문자 'A'의 유니코드인 65가 변수 i에 저장된다.
long l = 123;     // OK. int보다 long타입이 더 범위가 넓다.
double d = 3.14f; // OK. float보다 double 타입이 범위가 넓다.
```

<br>

그러나 리터럴의 값이 변수의 타입의 범위를 넘어서거나, 리터러의 타입이 변수의 타입보다 저장범위가 넓으면 컴파일 에러가 발생한다.

```java
int i = 0x123456789; // 에러. int 타입의 범위를 넘는 값을 저장
float f = 3.14;      // 에러. float 타입보다 double 타입의 범위가 넓다.
```

```java
byte b = 65;      // OK. byte타입에 저장 가능한 범위의 int타입 리터럴
short s = 0x1234; // OK. short타입에 저장 가능한 범위의 int타입 리터럴
```

값의 크기에 상관없이 `double → float 타입의 변수에 저장할 수 없다는 것만 주의 !`

<br>

<br>

### 문자 리터럴과 문자열 리터럴

'A'와 같이 작은따옴표를 문자 하나를 감싼 것을 `문자 리터럴` 이라고 한다. 두 문자 이상은 큰 따옴표로 감싸야 하며 `문자열 리터럴` 이라고 한다.

```java
char ch = 'J';        // char ch = 'Java'; 이렇게 할 수 없다
String name = "Java"; // 변수 name에 문자열 리터럴 "Java"를 저장
```

<br>

**문자열 리터럴**은 ""안에 아무런 문자도 넣지 않는 것을 **허용**하며, 이를 `빈 문자열(empty string)` 이라고 한다. 그러나 `문자 리터럴은 반드시 "안에 하나의 문자가 있어야 한다.`

```java
String str = ""; // OK. 내용이 없는 빈 문자열
char ch = '';    // 에러. ''안에 반드시 하나의 문자가 필요
char ch = ' ';   // OK. 공백 문자(blank)로 변수 ch를 초기화
```

<br>

String은 클래스이므로 아래과 같이 객체를 생성하는 연산자 new를 사용해야 하지만 특별히 위와 같은 표현도 허용한다.

```java
String name = new String("Java"); // String 객체를 생성
```

<br>

그리고 덧셈 연산자를 이용하여 문자열을 결합할 수 있어서 다음과 같이 할 수 있다.

```java
String name = "Ja" + "va"; // name은 "Java"
String str = name + 8.0;   // str은 "Java8.0"
```

<br>

<br>

### 3) 형식화된 출력 - prinf()

`println()` 은 변수의 값을 그대로 출력하므로, 값을 변환하지 않고는 다른 형식으로 출력할 수 없다. 같은 값이라도 다른 형식으로 출력하고 싶을 때가 있다. 예를 들면, 소수점 둘째자리까지만 출력한다던가, 정수를 16진수나 8진수로 출력한다거나.. 이럴 때 `prinf()` 를 사용하면 된다.

`printf()` 는 '지시자(specifier)' 를 통해 변수의 값을 여러 가지 형식으로 변환하여 출력하는 기능을 가지고 있다. '지시자'는 값을 어떻게 출력할 것인지를 지정해주는 역할을 한다.

```java
System.out.printf("age : %d" age);
System.out.printf("age : %d", 14);
System.out.printf("age : 14");     // "age : 14" 가 화면에 출력된다.
```

<br>

만일 값이 출력하는 값이 2개라면, 지시자도 2개를 사용해야 하며 출렬될 값과 지시자의 순서는 일치해야 한다. 물론 3개 이상의 값도 지시자를 지정해서 출력할 수 있으며 개수의 제한은 없다.

```java
System.out.printf("age : %d year : %d", age, year);
System.out.printf("age : %d year : %d", 14, 2017);

// "age : 14 yaer : 2017"이 화면에 출력된다.
```

<br>

**println()과 달리 printf()는 출력 후 줄바꿈을 하지 않는다. 줄바꿈을 하려면 지시자 `%n` 을 따로 넣어줘야 한다.**

> '%n' 대신 '\n'을 사용해도 되지만, OS마다 줄바꿈 문자가 다를 수 있기 때문에 '%n'을 사용하는 것이 더 안전하다.
> 

```java
System.out.printf("age : %d", age);   // 출력 후 줄바꿈을 하지 않는다.
System.out.printf("age : %d\n", age); // 출력 후 줄바꿈을 한다.
```

<br>

<br>

| 지시사 | 설명                                        |
| ------ | ------------------------------------------- |
| %b     | 블리언(boolean) 형으로 출력                 |
| %d     | 10진(decimal) 정수의 형식으로 출력          |
| %o     | 8진(octal) 정수의 형식으로 출력             |
| %x, %X | 16진(hexa-decimal) 정수의 형식으로 출력     |
| %f     | 부동 소수점(floating-point)의 형식으로 출력 |
| %e, %E | 지수(exponent) 표현식의 형식으올 출력       |
| %c     | 문자(character)로 출력                      |
| %s     | 문자열(string)로 출력                       |



<br>

정수를 출력할 때는 지시자 '%d'를 사용하는데, 출력될 값이 차지할 공간을 숫자로 지정할 수 있다. 여러 값을 여러 줄로 간격 맞춰 출려할 때 꼭 필요한 기능이다. 아래의 결과를 보면 '0'과 '-'가 어떤 역할을 하는지 알수있다.

```java
System.out.printf("finger = [%5d]\n", finger);  // finger = [   10]
System.out.printf("finger = [%-5d]\n", finger); // finger = [10   ]
System.out.printf("finger = [%05d]\n", finger); // finger = [00010]
```

<br>

지시자 '%x'와 '%o'에 `#` 을 사용하면 접두사 `0x` 와 `0` 이 각각 붙는다. 그리고 `%X` 는 16진수에 사용되는 접두사와 영문자를 대문자로 출력한다.

```java
System.out.printf("hex = %x\n", hex);  // hex = ffffffffffffffff
System.out.prinff("hex = %#x\n", hex); // hex = 0xffffffffffffffff
System.out.prinff("hex = %#X\n", hex); // hex = 0xFFFFFFFFFFFFFFFF
```

<br>

10진수를 2진수로 출력해주는 지시자는 없기 때문에, 정수를 2진 문자열로 변환해주는 `Integer.toBinaryString(int i)` 를 사용해야 한다. 이 메서드는 정수를 2진수로 변환해서 문자열로 반환하므로 지시자 '%s'를 사용

```java
System.out.printf("binNum = %s, %d\n", Integer.toBinaryString(binNum), binNum);
```

<br>

그리고 C언에서는 char타입의 값을 지시자 '%d'로 출력할 수 있지만, 자바에서는 허용되지 않는다. 아래와 같이 int타입으로 형변환해야만 '%d'로 출력할 수 있다.

```java
System.out.printf("c = %c, %d \n", c, (int) c); // 형변환이 꼭 필요하다.
```

```java
System.out.printf("d = %14.10f\n", d); // 전체 14자리 중 소수점 10자리

// 1 2 3 4 1 2 3 4 5 6 7 8 9 0
//     1 . 2 3 4 5 6 7 8 9 0 0 <- 빈자리를 0으로 채움
```

> 지시자를 '%014.10' 으로 지정했다면, 양쪽 빈자리를 모두 0으로 채웠을 것이다.
> 

지시자 `%s` 에도 숫자를 추가하면 원하는 만큼의 출력공간을 확보하거나 문자열의 일부만 출력할 수 있다.

```java
System.out.printf("[%s]\n", url);    // 문자열의 길이만큼 출력공간을 확보
System.out.printf("[%20s]\n", url);  // 최소 20글자 출력공간 확보. (우측정렬)
System.out.printf("[%-20s]\n", url); // 최소 20글자 출력공간 확보. (좌측정렬)
System.out.printf("[%.8s]\n", url);  // 왼쪽에서 8글자만 출력
```

<br>

<br>

### 4) 화면에서 입력받기 - Scanner

> 화면으로 부터 입력받는 방법들은 근복적으로 모두 같으므로 차이를 비교할 필요는 없다. 그저 상황에 맞는 편리한 것을 선택해서 사용하면 된다.
> 

Scanner 클래스를 사용하려면, 먼저 한 문장을 추가해 줘야 한다.

```java
import java.uitl.*; // Scanner 클래스를 사용하기 위해 추가
```

그리고 `nextLine()` 이라는 메서드를 호출하면, 입력대기 상태에 있다가 입력을 마치고 엔터키를 누르면 입력한 내용이 문자열로 반환된다.

```java
String input = scanner.nextLine(); // 입력받은 내용을 input에 저장
int num = Integer.parseInt(input); // 입력받은 내용을 int타입의 값으로 변환
```

<br>

Scanner 클래스에는 `nextLine()` 이나 `nextFloat()` 와 같이 변환없이 숫자로 바로 입력받을 수 있는 메서드들이 있고, 이 메서드들을 사용하면 문자열을 숫자로 변환하는 수고는 하지 않아도 된다.

<br>

<br>

<br>

## 3. 진법

---

### 1) 10진법과 2진법

컴퓨터는 2진 체계로 설계되었기 때문에, 2진법을 알지 못하면 컴퓨터의 동작원리나 데이터 처리방식을 온전히 이해할 수 없다.

```java
int age = 25; 

// 변수 age에 25를 저장
// age 25 --> age 11001
```

<br>

이처럼 2진법은 0과 1로만 데이터를 표현하기 때문에 10진법에 비해 많은 자리수를 필요로 한다. 10진수와 2와 같이 작은 숫자도 2진수로 표현하려면 2자리가 필요하다. 2진수 한자리로는 1보다 큰 값을 표현할 수 없기 때문이다.

이것은 10진수에서 9보다 큰 수를 표현하기 위해서는 두 자리의 10진수가 필요한 것과 같다.

그래서 2진수 1에 1을 더하면 2가 아닌 10이 되고, 2진수 11에 1을 더하면 12가 아닌 100이 된다.

```java
// 2진수
1 + 1 = 2
11 + 1 = 100

// 10진수
9 + 1 = 10
99 + 1 = 100
```

<br>

자리수가 많아지긴 해도 2진수는 10진수를 온전히 표현할 수 있다. 게다가 덧셈이나 뺄셈 같은 연산도 10진수와 동일하다.

<br>

<br>

### 2) 비트(bit)와 바이트(byte)

한 자리의 2진수를 `비트(bit, binary digit)` 라고 하며, 1비트는 컴퓨터가 값을 저장할 수 있는 최소단위이다. 

이 외에도 `워드(word)` 라는 단위가 있는데, `CPU가 한 번에 처리할 수 있는 데이터의 크기` 를 의미한다.

예를 들어 32비트 CPU에서 1워드는 32비트(4바이트)이고, 64비트 CPU에서는 64비트(8 바이트)이다.

<br>

<br>

### 3) 8진법과 16진법

**8진수는 2진수 3자리를, 15진수는 2진수 4자리를 각각 한자리로 표현할 수 있기 때문에 자리수가 짧아져서 알아보기 쉽고 서로 간의 변환방법 또한 매우 간단하다.**

<br>

8진법은 값을 표현하는데 8개의 기호가 필요하므로 0~7개의 숫자를 기호로 사용하면 되지만, 16진법은 16개의 기호가 필요하므로 0~9의 숫자만으로는 부족하다. 그래서 6개의 문자(A~F)를 추가로 사용한다. 예를 들어 `16진수 A는 10진수로 10이고, F는 15이다.`

<br>

### 2진수를 8진수, 16진수로 변환

```java
// 2진수 -> 8진수
000 -> 0
001 -> 1
010 -> 2
011 -> 3
100 -> 4
101 -> 5
110 -> 6
111 -> 7

// 2진수 -> 16진수
0000 -> 0
0001 -> 1
0002 -> 2
0010 -> 3
0011 -> 4
0100 -> 5
0101 -> 6
0110 -> 7
...
```

<br>

<br>

### 4) 정수의 진법 변환

### 10진수를 n진수로 변환

```java
46 / 2 --> 몫 : 23, 나머지 : 0
```

<br>

이 작업을 몫이 나누는 값인 2보다 작을 때까지 반복한다.

```java
46 / 2 -> 23 / 2 -> 11 ....

46(10) -> 10110(2)
```

```java
// 10진수 -> 16진수
10 -> A
11 -> B
12 -> C
13 -> D
14 -> E
15 -> F
```

<br>

<br>

### n진수를 10진수로 변환

```java
123 = 100 + 20 + 3
		= 1 X 100 + 2 X 10 + 3 X 1
		= 1 X 10^3 + 2 X 10^1 + 3 X 10^0
```

<br>

<br>

### 5) 실수의 진법변환

### 10진 소수점수를 2진 소수점수로 변환하는 방법

**10진 소수에 2를 곱한다.**

```java
0.625 x 2 = 1.25
```

<br>

**위의 결과에서 소수부만 가져다가 다시 2를 곱한다.**

```java
0.25 x 2 = 0.5
```

<br>

**1과 2의 과정을 소수부가 0이 될 때까지 반복한다.**

```java
0.625 x 2 = 1.25
0.25 x 2 = 0.5
0.5 x 2 = 1.0
```

위의 결과에서 정수부만을 위에서 아래로 순서대로 적고 `0.` 을 앞에 붙이면 된다.

```java
0.625(10) -> 0.101(2)
```

<br>

<br>

### 2진 소수점수를 10진 소수점수로 변환하는 방법

```java
0.625(10) = 6 x 10^(-1) + 2 x 10^(-2) + 5 x 10^(-3)
```

<br>

<br>

### 6) 음수의 2진 표현 - 2의 보수법

### 2의 보수법

어떤 수의 'n의 보수'는 `더했을 때 n이 되는 수` 를 말한다. 7의 '10의 보수'는 3이고, 3의 '10의 보수'는 7이다. 3과 7은 '10의 보수의 관계' 에 있다고 한다. '2의 보수 관계' 역시, 더해서 2가 되는 두 수의 관계를 말하며 10진수 2는 2진수로 '10'이다. 2진수로 '10'은 `자리올림이 발생하고 0이 되는 수` 를 뜻한다.  그래서 '2의 보수 관계'에 있는 두 2진수를 더하면 '(자리올림이 발생하고) `0이 된다.`'

```java
  0 1 0 1 <- 10진수로 5
+
  1 0 1 1 <- 10진수로 -5
---------
1 0 0 0 0 <- 자리올림이 발생했으나 크기가 4비트라서 버려짐
```

<br>

<br>

### 음수를 2진수로 표현하기

10진 음의 정수를 2진수로 변환하려면, 먼저 10진 음의 정수의 절대값을 2진수로 변환한다. 그 다음에 이 2진수의 '2의 보수'를 구하면 된다.

```java
-5(10) -> 절대값 -> 5(10) -> 2진수 -> 0101(2) -> 2의 보수 -> 1011(2)
```

<br>

- 2의 보수 쉽게 구하는 방법

```java
2의 보수 = 1의 보수 + 1 
```

<br>

'1의 보수'는 **0을 1로, 1을 0으로**만 바꾸면 되므로 구하기 쉽다.

```java
	0 1 0 1

	1 0 1 0 <- '0101'의 '1의 보수'
+
	1 0 1 1 <- '0101'의 '2의 보수'
```

<br>

- 정리

```
음수의 2진 표현을 구하는 방법
(1) 음수의 절대값을 2진수로 변환한다.
	-> -5의 절대값인 5를 2진수로 변환한다. 10진수 5를 2진수로 변환하면 '0101'이다.
(2) (1)에서 구한 2진수의 1을 0으로 0은 1로 바꾼다. (1의 보수 구하기)
	-> '0101'이 '1010'이 된다.
(3) (2)의 결과에 1을 더한다. (2의 보수 구하기, 1의 보수 + 1)
	-> '1010'에 1을 더하면 '1011'이 되고, 이것이 -5의 2진 표현이다.
```

<br>

<br>

<br>

## 4. 기본형(Primitive Type)

---

### 1) 논리형 - boolean

boolean형 변수에는 `true` 와 `false` 중 하나를 저장할 수 있으며 **기본값(default)은 false다.**

boolean형 변수는 1bit만으로도 충분하지만, 자바에서는 데이터를 다루는 최소단위가 byte이기 때문에, boolean의 크기가 1byte이다.

```java
boolean power = true;
boolean checked = False; // 에러. 대소문자가 구분됨. true 또는 false만 가능
```

<br>

<br>

### 2) 문자형 - char

문자형 역시 'char' 한 가지 자료형밖에 없다. 문자를 저장하기 위한 변수를 선언할 때 사용되며, char 타입의 변수는 단 하나의 문자만을 저장할 수 있다.

```java
char ch = 'A'; // 문자 'A'를 char타입의 변수 ch에 저장
```

<br>

위의 문장은 변수에 '문자'가 저장되는 것 같지만, 문자가 아닌 `문자의 유니코드(정수)` 가 저장된다. 컴퓨터는 숫자밖에 모르기 때문에 모든 데이터를 숫자로 변환하여 저장하는 것이다. 문자 'A'의 유니코드는 65이므로, 변수 ch에는 65가 저장된다.

<br>

그래서 문자 리터럴 대신 문자의 유니코드를 직접 저장할 수도 있다. 아래의 두 문장은 동일한 결과를 얻는다.

```java
char ch = 'A'; // 문자 'A'를 char타입의 변수 ch에 저장
char ch = 65;  // 문자의 코드를 직접 변수 ch에 저장
```

<br>

만일 어떤 문자의 유니코드를 알고 싶으면, char형 변수에 저장된 값을 정수형(int)으로 변환하면 된다.

```java
int code = (int) ch; // ch에 저장된 값을 int타입으로 변환하여 저장.
```

<br>

<br>

문자 'A'의 유니코드는 65(16진수로 0x41)이고, 문자 '가'의 유니코드는 44032(16진수로 0xAC00)이라는 것을 알 수 있다. 유니코드를 알면 아래와 같이 char형 변수에 문자를 저장할 때, 문자 리터럴 대신에 유니코드를 직접 사용할 수도 있다.

```java
char hch = 0xAC00;   // char hch = '가';
char hch = '\uAC00'; // 이렇게도 가능
```

<br>

<br>

### 특수 문자 다루기

영문자 이외에 tab이나 backspace 등의 특수문자를 저장하려면, 조금 특별한 방법을 사용한다.

```java
char tab = '\t'; // 변수 tab에 탭 문자를 저장
```

<br>

| 특수 문자            | 문자 리터럴                     |
| -------------------- | ------------------------------- |
| tab                  | \t                              |
| backspace            | \b                              |
| form feed            | \f                              |
| new line             | \n                              |
| carriage return      | \r                              |
| 역슬래시(\)          | \\                              |
| 작은따옴표           | \'                              |
| 큰따오폼             | \*                              |
| 유니코드(16진수)문자 | \u유니코드(예: char a='\u0041') |



<br>

<br>

### char타입의 표현방식

```
16비트로 표현할 수 있는 정수의 개수 : 2^16ro(65536개)
short타입의 표현범위 : -2^15 ~ 2^15 -1(-32768 ~ 32767)
char타입의 표현범위 : 0 ~ 2^16 -1(0~65535)
```

<br>

다음과 같이 변수 ch와 s에 'A'와 65를 저장하면, 둘 다 2진수로 똑같은 값이 저장된다. 컴퓨터는 모든 값을 0과 1로 바꾸어 저장하기 때문이다.

```java
char ch = 'A'; // char ch = 65;
short s = 65;
```

<br>

그런데도 두 변수의 값을 출력해보면 결과가 다르다. println()은 변수의 타입이 정수형이면 변수에 저장된 값을 10진수로 해석하여 출력하고, 문자형이면 저장된 숫자에 해당하는 유니코드 문자를 출력하기 때문이다.

```java
System.out.println(ch); // A가 출력된다.
System.out.println(s);  // 65가 출력된다.
```

이처럼 값은 어떻게 해석하느냐에 따라 결과가 달라지므로 값만으로는 값을 해석할 수 없다. 값의 타입까지 알아야 올바르게 해석할 수 있는 것이다.

<br>

<br>

### 인코딩과 디코딩(encoding & decoding)

```java
'A' --> 인코딩 --> 65
	  <-- 디코딩 <--
```



**유니코드(Unicode)**

| 문자 | 유니코드 |
| ---- | -------- |
| A    | 65       |
| B    | 66       |
| C    | 67       |



<br>

<br>

### 아스키(ASCII)

⇒ American Standard Code for Information Interchange' 의 약어로 정보교환을 위한 미국 표준 코드란 뜻이다. 아스키는 128개(=2^7)의 문자 집합(character set)을 제공하는 7bit 부호로, 처음 32개의 문자는 인쇄와 전송 제어용으로 사용되는 '제어문자(control character)'로 출력할 수 없고 마지막 문자(DEL)을 제외한 33번째 이후의 문자들은 출력할 수 있는 문자들로, 기호와 숫자, 영대소문자로 이우러져 있다.

<br>

<br>

### 확장 아스키(Extended ASCII)와 한글

⇒ 일반적으로 데이터는 byte 단위로 다뤄지는데 아스키는 7bit 이므로 1bit가 남는다. 이 남는 공간을 활용해서 문자를 추가로 정의한 것이 `확장 아스키` 이다. 확장 아스키에 추가된 128개의 문자는 여러 국가와 기업에서 서로의 필요에 따라 다르게 정의해서 사용.

확장 아스키로도 표현할 수 있는 문자의 개수가 255개뿐이므로 한글을 표현하기에는 턱없이 부족하다. 그래서 생각해낸 것이 두 개의 문자코드로 한글을 표현하는 방법이었다.

- 조합형 : 초성, 중성, 종성을 조합을 조합하는 방식
- 완성형 : 확장 아스키의 일부 영역(162~254)에 해당하는 두 문자코드를 조합하여 한글을 표현

<br>

<br>

### 코드 페이지(Code Page, CP)

⇒ IBM이 자사 자사 PC에 '확장 아스키'를 도입해서 사용하기 시작할 때, PC를 사용하는 지역이나 국가에 따라 여러 버전의 '확장 아스키'가 필요했다. IBM은 이들을 `코드 페이지` 라고 하고, 각 코드 페이지에 'CP xxx'와 같은 형식으로 이름을 붙였다.

<br>

<br>

### 유니코드(Unicode)

⇒ 예전엔 같은 지역 내에서만 문서교환이 주를 이뤘지만, 인터넷이 발명되면서 서로 다른 지역의 다른 언어를 사용하는 컴퓨터간의 문서교환이 활발해지기 시작하자 서로 다른 문자 인코딩을 사용한느 컴퓨터간의 문서교환에 어려움을 겪었다. 이러한 어려움을 해소하고자 전 세계의 모든 문자를 하나의 통일된 문자집합으로 표현하고자 노력하였고 그것이 `유니코드` 이다.

유니코드는 먼저 유니코드에 포함시키고자 하는 문자들의 집합을 정의하였는데, 이것을 유니코드 문자 셋(또는 캐릭터 셋, character set)이라고 한다. 그리고 이 문자 셋에 번호를 붙인 것이 유니코드 인코딩이다.

인코딩에는 UTF-8, UTF-16, UTF-32등 여러가지 종류가 있는데, 자바에서는 UTF-16을 사용한다.

UTF-16은 모든 문자를 2byte의 고정크기로 표현하고, UTF-8은 하나의 문자를 1~4byte의 가변크기로 표현한다.

<br>

<br>

### 3) 정수형 - byte, short, int, long

정수형에는 모두 4개의 자료형이 있으며, 각 자료형이 저장할 수 있는 값의 범위가 서로 다르다. 단위는 byte다.

```java
byte(1) < short(2) < int(4) < long(8)
```

byte부터 long까지 1byte부터 시작해서 2배씩 크기가 증가한다는 것을 알 수 있다.

기본 자료형(default data type)은 int이다.

<br>

**정수형의 표현범위**

| 타입  | 저장 가능한 값의 범위                                  | bit  | byte |
| ----- | ------------------------------------------------------ | ---- | ---- |
| byte  | -128 ~ 127                                             | 8    | 1    |
| short | -32,768 ~ 32.767                                       | 16   | 2    |
| int   | -2,147,483,648 ~ 2,147,483,647                         | 32   | 4    |
| long  | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 64   | 8    |



<br>

<br>

### 정수형의 선택기준

변수에 저장하려는 정수값의 범위에 따라 4개의 정수형 중에서 하나를 선택하면 되겠지만, byte나 short보다 int를 사용하도록 하자. byte와 short가 int보다 크기가 작아서 메모리를 조금 더 절약할 수는 있지만, 저장할 수 있는 값의 범위가 작은 편이라서 연산 시에 범위를 넘어서 잘못된 결과를 얻기가 쉽다.

그리고 JVM의 피연산자 스택(operand stack)이 피연산자를 4byte 단위로 저장하기 때문에 크기가 4byte보다 작은 자료형(byte, short)의 값을 계산할 때는 4byte로 변환하여 연산이 수행된다. 

**그래서 오히려 int를 사용하는 것이 더 효율적이다.**

결론적으로 `정수형 변수를 선언할 때는 int타입으로 하고, int의 범위(약 20억)를 넘어서는 수를 다뤄할 때는 long을 사용하면 된다.`

그리고 byte나 short는 성능보다 저장공간을 절약하는 것이 더중요할 때 사용하자.

<br>

<br>

### 정수형의 오버플로우

⇒ 연산과정에서 해당 `타입이 표현할 수 있는 값의 범위를 넘어서는 것을 오버플로우(overflow)`라고 한다.

```
최대값 + 1 -> 최소값
최소값 - 1 -> 최대값
```

<br>

<br>

### 부호있는 정수의 오버플로우

부호있는 정수는 부호비트가 0에서 1이 될 때 오버플로우가 발생한다.

```java
sMin - 1 --> sMax // 최소값 - 1 --> 최대값
sMax + 1 --> sMin // 최대값 + 1 --> 최소값
cMin - 1 --> cMax // 최소값 - 1 --> 최대값
xMax + 1 --> cMin // 최대값 + 1 --> 최소값
```

<br>

<br>

### 4) 실수형 - float, double

<br>

**실수형의 범위와 정밀도**

| 타입   | 저장 가능한 값의 범위(양수)  | 정밀도 | bit  | byte |
| ------ | ---------------------------- | ------ | ---- | ---- |
| float  | 1.4 x 10^-45 ~ 3.4 x 10^38   | 7자리  | 32   | 4    |
| double | 4.9 x 10^-324 ~ 1.8 x 10^308 | 15자리 | 64   | 8    |



<br>

실수형에는 오버플로우가 발생하면 변수의 값은 `무한대(infinity)` 가 된다.

그리고 정수형에는 없는 `언더플로우(underflow)` 가 있는데, 실수형으로 표현할 수 없는 아주 작은 값, 즉 양의 최소값보다 작은 값이 되는 경우를 말한다.

<br>

float 타입은 정밀도가 7자리인데, '7자리의 10진수를 오차없이 저장할 수 있다'는 뜻으로 아래의 세 값은 float타입의 변수에 저장했을 때 오차없이 저장할 수 있다.

```java
1234.567      = 1.234567 x 10^3
0.00001234567 = 1.234567 x 10^-5
1234567000    = 1.234567 x 10^9
```

<br>

만일 7자리 이상의 정밀도가 필요하면, 변수의 타입을 double로 해야 한다. double 타입은 float 타입보다 정밀도가 약2배인, 10진수로 15자리의 정밀도를 가지므로 float 타입보다 훨씬 더 정밀하게 값을 표현할 수 있다.

실수형 값을 저장할 때, float타입이 아닌 double타입의 변수를 사용하는 경우는 대부분 저장하려는 '값의 범위' 때문이 아니라 '보다 높은 정밀도'가 필요해서이다.

연산속도의 향상이나 메모리를 절약하려면 float를 선택하고, 더 큰 값의 범위라던가 더 높은 정밀도를 필요로 한다면 double을 선택해야 한다.

<br>

<br>

### 실수형의 저장식

실수형은 정수형과 표현형식이 달라서, 실수형은 값을 부동소수점수(floating-point)의 형태로 저장한다. 부동소수점수는 부호(Sign), 지수(Exponent), 가수(Mantissa), 모두 세 부분으로 이루어져 있다.

<br>

**실수 표현형식의 구성요소**

| 기호 | 의미           | 설명                                                         |
| ---- | -------------- | ------------------------------------------------------------ |
| S    | 부호(Sign bit) | 0이면 양수, 1이면 음수                                       |
| E    | 지수(Exponent) | 부호있는 정수, 지수의 범위는 -127 ~ 128(float), -1023 ~ 1024(double) |
| M    | 가수(Mantissa) | 실제값을 저장하는 부분. 10진수로 7자리(float), 15자리(double)의 정밀도로 저장 가능 |

<br>

### 부동소수점의 오차

실수 중에는 파이(3.141592...)와 같은 무한소수가 존재하므로, 정수와 달리 실수를 저장할 때는 오차가 발생할 수 있다. 게다가 10진수가 아닌 2진수로 저장하기 때문에 10진수로는 유한소수이더라도, 2진수로 변환하면 무한소수가 되는 경우도 있다.

<br>

Float 클래스의 `floatToIntBits()` 는 float타입의 값을 int타입의 값으로 해석해서 반환한다. 변환된 값으 16진수로 출력하면, float 타입의 값이 2진수로 어떻게 저장되는지 확인할 수 있다.

<br>

<br>

<br>

## 5. 형변환

---

### 1) 형변환(캐스팅, casting)이란?

프로그램을 작성하다 보면 같은 타입뿐만 아니라 서로 다른 타입간의 연산을 수행해야하는 경우도 있다. 이럴 때는 연산을 수행하기 전에 타입을 일치시켜야 하는데, 변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 `형변환(casting)` 이라고 한다.

```
형변환이란, 변수 또는 상수으 ㅣ타입을 다른 타입으로 변환하는 것
```

<br>

<br>

### 2) 형변환 방법

형변환 방법은 매우 간단하다. 형변환하고자 하는 변수나 리터럴의 앞에 변환하고자 하는 타입을 괄호와 함께 붙여주기만 하면 된다.

```
(타입)피연산자
```

<br>

여기에 사용되는 괄호()는 `캐스트 연산자` 또는 `형변환 연산자` 라고 하며, 형변환을 `캐스팅(casting)` 이라고 한다.

```java
double d = 85.4;
int score = (int) d; // double 타입의 변수 d를 int 타입으로 형변환
```

<br>

**기본형간의 형변환**

| 변환         | 수식       | 결과  |
| ------------ | ---------- | ----- |
| int -> char  | (char) 65  | 'A'   |
| char -> int  | (int) 'A'  | 65    |
| float -> int | (int) 1.6f | 1     |
| int -> float | (float) 10 | 10.0f |

<br>

<br>

### 4) 실수형 간의 형변환

실수형에서도 정수형처럼 작은 타입에서 큰 타입으로 변환하는 경우, 빈 공간을 0으로 채운다. float 타입의 값을 double 타입으로 변환하는 경우, 지수(E)는 float의 기저인 127을 뺀 후 double의 기저인 1023을 더해서 변환하고, 가수(M)는 float의 가수 23자리를 채우고 남은 자리를 0으로 채운다.

float타입의 범위를 넘는 값을 float로 형변환하는 경우는 '무한대' 또는 '0'을 결과로 얻는다.

```java
double d = 1.0e100; // float의 최대값보다 큰 값을 d에 저장
float f = (float)d; // d의 값을 float로 형변환해서 f에 저장. f는 무한대가 된다.

double d = 1.0e-50; // float의 최소값보다 작은 값을 d에 저장
float f = (float)d; // f의 값은 0이 된다.
```

<br>

<br>

### 5) 정수형과 실수형 간의 형변환

실수형을 정수형으로 형변환 할 때 반올림이 발생하지 않는다.

```java
1.666 --> (int) --> 1
```

<br>

<br>

### 6) 자동 형변환

서로 다른 타입간의 대입이나 연산을 할 때, 형변환으로 타입을 일치시키는 것이 원칙이다. 하지만, 경우에 따라 편의상의 이유로 형변환을 생략할 수 있다. 그렇다고 해서 형변환이 이루어지지 않는 것은 아니고, 컴파일러가 생략된 형변환을 자동적으로 추가한다.

```java
float f = 1234; // 형변환의 생략. float f = (float)1234; 와 같음
```

<br>

그러나 다음과 같이 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에 형변환을 생략하면 에러가 발생한다.

```java
byte b = 1000; // 에러. byte의 범위(-128~127)를 넘는 값을 저장.
```

<br>

에러 메시지는 `incompatible types: possible lossy conversion from int to byte` 인데, 큰 타입에서 작은 타입으로의 형변환은 값 손실이 발생할 수 있다는 뜻이다.

그러나 다음과 같이 `명시적으로 형변환 해줬을 경우` , 형변환이 프로그래머의 실수가 아닌 의도적인 것으로 간주하고 컴파일러는 에러를 발생시키지 않는다.

```java
char ch = (char)1000; // 명시적 형변환. 에러가 발생하지 않는다.
```

<br>

다음과 같은 계산식에서 자주 형변환이 생략되는데, 서로 다른 두 타입의 연산에서 먼저 타입을 일치시킨 다음에 연산을 수행해야 하므로, 연산과정에서 형변환이 자동적으로 이루어진다.

```java
int i = 3;
double d = 1.0 + i; // double d = 1.0 + (double)i; 에서 형변환이 생략됨
```

<br>

서로 다른 두 타입간의 덧셈에서는 두 타입 중 표현범위가 더 넓은 타입으로 형변환하여 타입을 일치시킨 다음에 연산을 수행시킨다.

```java
double d = 1.0 + i;
-> double d = 1.0 + (doube)i;
-> double d = 1.0 + (double)3; // 3을 double 타입으로 형변환하면 3.0이 된다.
-> double d = 1.0 + 3.0;       // double과 double의 덧셈결과 타입은 double.
-> double d = 4.0              // double + double = double
```

<br>

이처럼 연산과정에서 자동적으로 발생하는 형변환을 `산술 변환` 이라고 한다.

<br>

<br>

### 자동 형변환의 규칙

```
기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.
```

![picture](https://github.com/JaeYeon33/TIL/blob/main/JAVA/image/Untitled%202.png?raw=true)

1. boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
2. 기본형과 참조형은 서로 형변환할 수 없다.
3. 서로 다른 타입의 변수간의 형변환을 하는 것이 원칙이지만,
값의 범위가 작은 타입에서 큰 타입으로의 형변환을 생략할 수 있다.