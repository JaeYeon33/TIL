## 1. 배열(Array)

---

### 1) 배열(Array)이란?

같은 타입의 여러 변수를하나의 묶음으로 다루는 것을 `배열(Array)` 이라고 한다.

많은 양의 데이터를 저장하기 위해서, 그 데이터의 숫자만큼 변수를 선언해야 한다면 매우 혼란스러울 것이다.

10,000개의 데이터를 저장하기 위해 같은 수의 변수를 선언해야한다면 상상하는 것만으로도 상당히 곤혹스러울 것이다.

이런 경우에 배열을 사용하면 많은 양의 데이터를 손쉽게 다룰 수 있다.

```java
"배열은 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것"
```

<br>

여기서 중요한 것은 '같은 타입' 이어야 한다는 것이며, 서로 다른 타입의 변수들로 구성된 배열은 만들 수 없다.

만일 배열을 사용하지 않는다면 학생 5명의 점수를 저장하기 위해서 아래와 같이 5개의 변수를 선언해야 할 것이다.

```java
int score1, score2, score3, score4, score5;
```

<br>

변수 대신 배열을 이용하면 다음과 같이 간단히 처리할 수 있다. 변순의 선언과 달리 다뤄야할 데이터의 수가 아무리 많아도 단지 배열의 길이만 바꾸면 된다.

```java
int[] score = new int[5]; // 5개의 int 값을 저장할 수 있는 배열을 생성한다.
```

<br>

<br>

### 2) 배열의 선언과 생성

배열을 선언하는 방법은 간단하다. 타입의 변수를 선언하고 변수 또는 타입에 배열임을 의미하는 대괄호[]를 붙이면 된다.

**배열의 선언방법과 선언 예**

| 선언방법          | 선언 예                          |
| ----------------- | -------------------------------- |
| 타입[] 변수 이름; | int[] score;<br />String[] name; |
| 타이 변수이름[];  | int score[];<br />String name[]; |

<br>

<br>

### 배열의 생성

배열을 선언한 다음에는 배열을 생성해야 한다. 배열을 선언하는 것은 단지 생성된 배열을 다루기 위한 참조변수를 위한 공간이 만들어질 뿐이고, 배열을 생성해야만 비로소 값을 저장할 수 있는 공간이 만들어지는 것이다.

배열을 생성하기 위해서는 연산자 'new'와 함께 배열의 타입과 길이를 지정해 주어야 한다.

```java
타입[] 변수이름;           // 배열을 선언 (배열을 다루기 위한 참조변수 선언)
변수이름 = new 타입[길이];  // 배열을 생성 (실제 저장공간을 생성)
```

<br>

아래의 코드는 '길이가 5인 int배열'을 생성한다.

```java
int[] score;        // int타입의 배열을 다루기 위한 참조변수 score 선언
score = new int[5]; // int타입의 값 5개를 저장할 수 있는 배열
```

<br>

<br>

### 3) 배열의 길이와 인덱스

생셩된 배열의 각 저장공간을 '배열의 요소(element)' 라고 하며, '배열이름[인덱스]'의 형식으로 배열의 요소에 접근한다. `인덱스(index)는 배열의 요소마다 붙여진 일련번호` 로 각 요소를 구별하는데 사용된다.

다만 인덱스는 1이 아닌 0부터 시작한다.

```java
"인덱스(index)의 범위는 0부터 '배열의길이 -1'까지."
```

배열의 값을 저장하고 읽어오는 방법은 변수와 같다. 단지 변수이름 대신 '배열이름[인덱스]'를 사용한다는 점만 다르다.

```java
score[3] = 100;       // 배열 score의 4번째 요소에 100을 저장한다.
int value = score[3]; // 배열 score의 4번째 요소에 저장된 값을 읽어서 value에 저장
```

<br>

배열을 다룰 때 한 가지 주의할 점은 index의 범위를 벗어난 값을 index로 사용하지 않아야 한다는 점이다. 예를 들어 다음과 같이 길이가 5인 배열이 선언되어 있을 때, index의 범위는 0~4이다. 이 때, 이 범위를 벗어나는 값이 5를 index로 사용하면 안된다는 이야기이다.

```java
int[] score = new int[5]; // 길이가 5인 int배열. index의 범위는 0~4
					...
score[5] = 100; // index의 범위를 벗어난 값을 index로 사용
```

<br>

유효한 범위를 벗어난 값을 index로 사용하는 것은 배열을 다룰 때 하는 가장 흔한 실수이다. 그러나 컴파일러는 이러한 실수를 걸러주지 못한다. 왜냐하면 배열의 index로 변수를 많이 사용하는데, 변수의 값은 실생 시에 대입되므로 컴파일러는 이 값의 범위를 확인할 수 없다.

그래서 유효한 범위의 값을 index로 사용하는 것은 전적으로 프로그래머의 책임이며, 유효하지 않는 값을 index로 사용하면, 무사히 컴파일을 마쳤더라도 실행 시에 에러(ArrayIndexOutOfBoundsException)가 발생한다.

<br>

배열 score는 길이가 5이므로 index의 범위가 0~4이지만, 일부러 이 범위에 속하지 않는 7을 배열의 index로 해서 값을 출력해보았다. 컴파일 시에는 아무런 문제가 없지만, 실행 시에는 아래와 같은 에러가 발생하였다.

```java
Exception in thread "main" java.lnag.ArrayIndexOutOfBoundsException: 7
				at ArrayEx1.main(ArrayEx1.java:20)
```

위 메시지는 배열의 인덱스가 유효한 범위를 넘었다는 뜻이다.

<br>

<br>

### 배열의 길이

앞서 배운 것과 같이 배열을 생성할 때 괄호[] 안에 배열의 길이를 적어줘야 하는데, 배열의 길이는 배열의 요소의 개수, 즉 값을 저장할 수 있는 공간의 개수이다.

당연하게도 배열의 길이는 양의 정수이어야 하며 최대값은 int타입의 최대값, 약 20억이다. 실제로 이렇게 큰 배열을 생성하는 경우는 꽤 드무니까 `배열의 길이는 거의 제약이 없다고 할 수 있다.`

```java
타입[] 배열이름 = new 타입[길이];
int[] arr    = new int[5];   // 길이가 5인 int배열
```

<br>

그런데 길이가 0인 배열도 생성이 가능하다. 길이가 0이라는 이야기는 값을 저장할 수 있는 공간이 하나도 없다는 뜻인데, 이런 배열을 생성하는 것이 무슨 의미가 있을까?

```java
int[] arr = new int[0]; // 길이가 0인 배열도 생성이 가능하다.
```

```java
배열의 길이는 int범위의 양의 정수(0도 포함)이어야 한다.
```

<br>

<br>

### 배열이름.length

자바에서는 JVM이 모든 배열의 길이를 별도로 관리하며, '배열이름.length'를 통해서 배열의 길이에 대한 정보를 얻을 수 있다.

```java
in[] arr = new int[5];  // 길이가 5인 int 배열
int tmp = arr.length;   // arr.length의 값은 5이고 tmp에 5가 저장된다.
```

<br>

배열은 한번 생성하면 길이를 변경할 수 없기 때문에, 이미 생성된 배열의 길이는 변하지 않는다. 따라서 '배열이름.lenght'는 `상수`다. 즉, 값을 읽을 수만 있을 뿐 변경하 수 없다.

```java
int[] arr = new int[5];
arr.length = 10;         // 에러. 배열의 길이는 변경할 수 없음
```

<br>

아래의 코드는 배열의 각 요소를 for문을 이용해서 출력한다. 여기서 배열 score의 길이는 6이며, 인덱스의 범위는 0 ~5이다.

```java
int[] score = new int[6];

for (int i = 0; i < 6; i++) {
		System.out.println(score[i]);
}
```

<br>

이 떄 코드를 변경하여 배열의 길이를 줄인다면, 유효한 인덱스의 범위는 0~4가 된다.

```java
int[] score = new int[5];           // 배열의 길이를 6에서 5로 변경

for (int i = 0; i < 6; i++) {       // 실수로 조건식을 변경하지 않음
		System.out.println(score[i]);   // 에러 발생.
}
```

<br>

5번째 반복에서 `ArrayIndexOutOfBoundsException` 이라는 예외(배열의 index가 유효한 범위를 벗어났다는 에럭)가 발생하여 비정상적으로 종료될 것이다.

그래서 for문의 조건식에 배열의 길이를 직접 적어주는 것 보다 '배열이름.length'를 사용하는 것이 좋다.

```java
int[] score = new int[5];                      // 배열의 길이를 6에서 5로 변경

for (int i = 0; i < score.length; i++) {       // 조건식을 변경하지 않아도 됨
		System.out.println(score[i]);   
}
```

<br>

'배열이름.length'는 배열의 길이가 변경되면 자동적으로 변경된 배열의 길이를 값으로 갖기 때문에, 배열과 함께 사용되는 for문의 조건식을 일일히 변경해주지 않아도 된다.

<br>

<br>

### 배열의 길이 변경하기

배열의 길이를 변경하는 방법

1. 더 큰 배열을 새로 생성한다.
2. 기존 배열의 내용을 새로운 배열에 복사한다.

이러한 작업들은 꽤나 비용이 많이 들기 때문에, 처음부터 배열의 길이를 넉넉하게 잡아줘서 새로 배열을 생성해야하는 상황이 가능한 적게 발생하도록 해야 한다.

<br>

<br>

### 4) 배열의 초기화

배열은 생성과 동시에 자동적으로 자신의 타입에 해당되는 기본값으로 초기화되므로 배열을 사용하기 전에 따로 초기화를 해주지 않아도 되지만, 원하는 값을 저장하려면 각 요소마다 값을 지정해 줘야한다.

```java
int[] score = new int[5];  // 길이가 5인 int형 배열을 생성한다.
score[0] = 50;             // 각 요소에 직접 값을 저장한다.
score[1] = 60;
score[2] = 70;
score[3] = 80;
score[4] = 90;
```

<br>

배열의 길이가 큰 경우네느 이렇게 요소 하나하나에 값을 지정하기 보다는 for문을 사용하는 것이 좋다.

```java
int[] score = new int[5];    // 길이가 5인 int형 배열을 생성한다.

for (int i = 0; i < score.length; i++)
		score[i] = i * 10 + 50;
```

<br>

그러나 for문으로 배열을 초기화하려면, 저장하려는 값에 일정한 규칙이 있어야만 가능하기 때문에 자바에서는 다음과 같이 배열을 간단히 초기화 할 수 있는 방법을 제공한다.

```java
int[] score = new int[] { 50, 60, 70, 80, 90 }; // 배열의 생성과 초기화를 동시에
```

<br>

저장할 값들을 괄호{} 안에 쉼표로 구분해서 나열하면 되며, 괄호{} 안의 값의 개수에 대해 배열의 길이가 자동으로 결졍되기 때문에 괄호{} 안에 배열의 길이는 안적어도 된다.

```java
int[] score = new int[] { 50, 60, 70, 80, 90 };
int[] score = { 50, 60, 70, 80, 90 }; // new int[]를 생략할 수 있음
```

<br>

심지어 'new 타입[]' 을 생략하여 코드를 더 간략히 할 수도 있다. 다만 `다음과 같이 배열의 선언과 생성을 따로 하는 경우에는 생략할 수 없다는 점만 주의하면 된다.`

```java
int[] score;
score = new int[] { 50, 60, 70, 80, 90 };  // OK.
score = { 50, 60, 70, 80, 90 };            // 에러. new int[]를 생략할 수 없음.
```

<br>

또 다른 예로. 아래와 같이 매개변수로 int배열을 받는 add메서드가 정의되어 있고 이 메서드를 호출해야할 경우 역시 'new 타입[]'을 생략할 수 없으며, 이유는 같다. 

```java
int add(int[] arr) { /* 내용 생략 */ }                  // add 메서드
int result = add(new int[] { 100, 90, 80, 70, 60 };   // OK
int result = add({ 100, 90, 80, 70, 60 });            // 에러. new int[]를 생략할 수 없음
```

<br>

그리고 괄호{}안에 아무 것도 넣지 않으면, 길이가 0인 배열이 생성된다. 참조변수의 기본 값은 null이지만, 배열을 가리키는 참조변수는 nul대신 길이가 0인 배열로 초기화하기도 한다.

```java
int[] score = new int[0];   // 길이가 0인 배열
int[] score = new int[] {}; // 길이가 0인 배열
int[] score = {};           // 길이가 0인 배열. new int[]가 생략됨
```

<br>

<br>

### 배열의 출력

배열을 초기화할 때 for문을 사용하듯이, 배열에 저장된 값을 확인할 때도 다음과 같이 for문을 사용하면 된다.

```java
int[] iArr = { 100, 95, 80, 70, 60 };

// 배열의 요소를 순서대로 하나씩 출력
for (int i = 0; i < iArr.length; i++) {
		System.out.println(iArr[i]);
}
```

<br>

더 간단한 방법은 `Arrays.toString(배열이름)` 메소드를 사용하는 것이다. 이 메서드는 배열의 모든 요소를

'[첫번째 요소, 두번째 요소, ...]' 와 같은 형식의 문자열로 만들어서 반환한다.

> Arrays.toString()을 사용하려면 `import.java.util.*` 를 추가해야 한다.

<br>

```java
int[] iArr = { 100, 95, 80, 70, 60 };

// 배열 iArr의 모든 요소를 출력한다. [100, 95, 80, 70, 60]이 출력된다.
System.out.println(Arrays.toString(iArr));
```

<br>

만일 iArr의 값을 바로 출력하면 어떻게 될까? 그러나 `타입@주소` 의 형식으로 출력된다. '[]'는 1차원 int배열이라는 의미이고, '@'뒤에 나오는 16진수는 배열의 주소인데 실제 주소가 아닌 내부 주소이다.

```java
// 배열을 가리키는 참조변수 iArr의 값을 출력한다.
System.out.println(iArr); // [I@143124b]와 같은 형식의 문자열이 출력된다.
```

<br>

예외적으로 char배열은 println 메서드로 출력하면 각 요소가 구분없이 그대로 출력되는데, 이것은 println 메서드가 char배열일 때만 이렇게 동작되도록 작성되었기 때문이다.

```java
char[] chArr = { 'a', 'b', 'c', 'd' };
System.out.prntln(chArr);  // abcd가 출력된다.
```

<br>

<br>

### 5) 배열의 복사

배열은 한번 생성하면 그 길이를 변경할 수 없기 때문에 더 많은 저장공간이 필요하다면 보다 큰 배열을 새로 만들고 이전 배열로부터 내용을 복사해야한다고 했다.

배열을 복사하는 방법은 두 가지가 있는데, 먼저 for문을 이용해서 배열을 복사하는 방법은 다음과 같다.

```java
int[] arr = new int[5];

...

int[] tmp = new int[arr.length * 2]; // 기존 배열보다 길이가 2배인 배열 생성

for (int i = 0; i < arr.lenght; i++)
		tmp[i] = arr[i];                 // arr[i]의 값을 tmp[i]에 저장

arr = tmp;                           // 참조변수 arr이 새로운 배열을 가리키게 한다.
```

<br>

이러한 작업들은 꽤나 비용이 많이 들기 때문에, 처음부터 배열의 길이를 넉넉하게 잡아줘서 새로 배열을 생성해야하는 상황이가능한 적게 발생하도록 해야 한다. 그렇다고 배열의 길이를 너무 크게 잡으면 메모리를 낭비하게 되므로, 위의 코드에서처럼 기존의 2배 정도의 길이로 배열을 생성하는 것이 좋다.

**배열 arr의 길이인 arr.length의 값이 5이므로 길이가 10인 int배열 tmp가 생성되었고, 배열 tmp의 각 요소는 int의 기본값인 0으로 초기화된다.**

```java
   int[] tmp = new int[arr.lenght * 2];
-> int[] tmp = new int[5 * 2];
-> int[] tmp = new int[10];
```

<br>

**for문을 이용해서 배열 arr의 모든 요소에 저장된 값을 하나씩 배열 tmp에 복사한다.**

```java
for (int i = 0; i < arr.length; i++)
		tmp[i] = arr[i];
```

<br>

**참조변수 arr에 참조변수 tmp의 값을 저장한다. arr의 값은 0x100에서 0x200으로 바뀌고, arr은 배열 tmp를 가리키게 한다.**

```java
arr = tmp;  // 변수 tmp에 저장된 값을 변수 arr에 저장한다.
```

결국 참조변수 arr과 tmp는 같은 배열을 가리키게 된다. 즉, 배열 arr과 배열tmp는 이름만 다를 뿐 동등한 배열이다. 그리고 전에 arr이 가리키던 배열은 더 이상 사용할 수 없게 된다.

<br>

<br>

### System.arraycopy()를 이용한 배열의 복사

for문 대신 System클래스의 arraycopy()를 사용하면 보다 간단하고 빠르게 배열을 복사할 수 있다. for문은 배열의 요소 하나하나에 접근해서 복사하지만, arraycopy()는 지정된 범위의 값들을 한 번에 통째로 복사한다.

각 요소들이 연속적으로 저장되어 있다는 배열의 특성 때문에 이렇게 처리하는 것이 가능한 것이다.

```java
배열의 복사는 for문보다 System.arraycopy()를 사용하는 것이 효율적이다.
```

<br>

배열의 복사에 사용된 for문을 arraycopy()로 바꾸면 다음과 같다.

```java
for (int i = 0; i < num.length; i++) { newNum[i] = num[i]; }
```

```java
System.arraycopy(num, 0, newNum, 0, num.length);

// num[0]에서 newNum[0]으로 num.length개의 데이터를 복사
```

<br>

복사하려는 배열의 위치가 적절하지 못하여 복사하려는 내용보다 여유 공간이 적으면 에러(`ArrayIndexOutOfBoundsException`)가 발생한다.

<br>

<br>

### 임의의 값으로 배열 채우기

배열을 연속적인 범위의 임의의 값으로 채우는 것은 다음과 같임 random()만 사용하면 쉽게 할 수 있을 것이다.

```java
for (i = 0; i < arr.legnth; i++) {
		arr[i] = (int)(Math.random() * 5); // 0~4범위의 임의의 값을 저장
}
```

그러면, 불연속적인 범위의 값들로 배열을 채우는 것은 어떻게 해야 할까? 배열을 하나 더 사용하면 된다. 먼저 배열 code에 불연속적인 값들을 담고, 임의로 선택된 index에 저장된 값으로 배열 arr의 요소들을 하나씩 채우면 되는 것이다. 저장된 값에 상관없이 배열의 index는 항상 연속적이기 때문이다.

<br>

<br>

<br>

## 2. String 배열

---

### 1) String 배열의 선언과 생성

배열의 타입이 String인 경우에도 int배열의 선언과 생성방법은 다르지 않다. 예를 들어 3개의 문자열(String)을 담을 수 있는 배열을 생성하는 문장은 다음과 같다.

```java
String[] name = new String[3];  // 3개의 문자열을 담을 수 있는 배열을 생성한다.
```

<br>참고로 변수의 타입에 따른 기본값은 다음과 같다.

<br>

**타입에 따른 변수의 기본값 (default value)**

| 자료형           | 기본값        |
| ---------------- | ------------- |
| boolean          | false         |
| char             | '\u0000'      |
| byte, short, int | 0             |
| long             | 0L            |
| float            | 0.0f          |
| double           | 0.0d 또는 0.0 |
| 참조형 변수      | null          |



<br>

<br>



### 2) String 배열의 초기화

초기화 역시 int배열과 동일한 방법으로 한다. 아래과 같이 각 배열의 요소에 문자열을 지정하면 된다.

```java
String[] name = new String[3]; // 길이가 3인 String 배열을 생성
name[0] = "Kim";
name[1] = "Park";
name[2] = "Yi";
```

<br>

또는 괄호{}를 사용해서 다음과 같이 간단히 초기화 할 수도 있다.

```java
String[] name = new String[]{"Kim", "Park", "Yi"};
String[] name = name { "Kim", "Park", "Yi" }; // new String[]을 생략할 수 있음
```

특별히 String 클래스만 "Kim"과 같이 큰따옴표만으로 간략히 표현하는 것이 혀용되지만, 원래 String은 클래스이므로 new 연산자를 통해 객체를 생성해야만 한다.

<br>

<br>

### 3) char 배열과 String 클래스

```
String 클래스는 char배열에 기능(메서드)를 추가한 것이다.
```

자바에서는 char배열과 그에 관련된 기능들을 함께 묶어서 클래스에 정의한다. 객체지향개념이 나오기 이전의 언어들은 데이터와 기능을 따로 다루었지만, 객체지향언어에서는 데이터와 그에 관련된 기능을 하나의 클래스에 묶어서 다룰 수 있게 한다. 즉, 서로 관련된 것들끼리 데이터와 기능을 구분하지 않고 함께 묶는 것이다.

여기서 말하는 '기능'은 함수를 의미하며, 메서드는 객체지향 언어에서 '함수' 대신 사용하는 언어일 뿐 함수와 같은 뜻이다. 앞으로 '기능' 이나 '함수' 대신 '메서드'라는 용어를 사용할 것이다.

char배열과 String클래스의 한 가지 중요한 차이가 있는데, String객체(문자열)는 읽을 수만 있을 뿐 내용을 변경할 수 없다는 것이다.

```java
String str = "JAVA";
str = str + "8";         // "Java8" 이라는 새로운 문자열이 str에 저장된다.
System.out.println(str); // "Java8"
```

> 변경 가능한 문자열을 다루려면 StringBuiler 클래스를 사용하면 된다.

<br>

<br>

### String 클래스의 주요 메서드

<br>

| 메서드                             | 설명                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| char charAt(int index)             | 문자열에서 해당 위치(index)에 있는 문자를 반환한다.          |
| int length()                       | 문자열의 길이를 반환한다.                                    |
| String substring(int from, int to) | 문자열에서 해당 범위(from~to)에 있는 문자열을 반환한다. <br>(to는 범위에 포함하지 않음) |
| boolean equals(Object obj)         | 문자열의 내용이 obj와 같은지 확인한다. 같으면 결과는 true, 다르면 false가 된다. |
| char[] toCharArray()               | 문자열을 문자배열(char[])로 변환해서 반환한다.               |



<br>

`charAt메서드` 는 문자열에서 지정된 index에 있는 한 문자를 가져온다. 배열에서 '배열이름[index]'로 index에 위치한 값을 가져오는 것과 같다고 생각하면 된다. 마찬가지로 charAt메서드의 index값은 0부터 시작한다.

```java
String str = "ABCDE";
Char ch = str.charAt(3); // 문자열 str의 4번째 문자 'D'를 ch에 저장
```

<br>

### char배열과 String클래스의 변환

가끔 char배열을 String클래스로 변환하거나, 또는 그 반대로 변환해야하는 경우가 있다.

그럴 떄 다음의 코드를 사용하자.

```java
char[] chArr = { 'A', 'B', 'C' };
String str = new String(chArr);  // char배열 --> String
char[] tmp = str.toCharArray();  // String --> char배열
```

<br>

String클래스의 charAt(int idx)을 사용하는 방법을 보여주는 예제이다. charAt(int idx)은 문자열 중에서 idx번째 위치에 있는 문자를 반환한다. idx의 값은 배열처럼 0부터 시작한다는 것을 확인하자.

<br>

이전의 16진수를 2진수로 변환하는 에제와 같지만, char배열 대신 이번엔 String을 사용했다.

<br>

String의 문자의 개수는 length()를 통해서 얻을 수 있고, charAt(int i)메서드는 String의 i번째 문자를 반환한다. 그래서 for문의 조건식에 length()를 사용하고 charAt(int i)를 통해서 source에서 한 문자씩 차례대로 읽어올 수 있다.

```java
	 result += morse[source.charAt(i) - 'A'];  // i가 0일 때
-> result += morse[source.charAt(0) - 'A'];  // source.charAt(0)는 첫 번째 문자
-> result += morse['S' - 'A'];               // 'S' - 'A' --> 83 - 65 --> 18
-> result += "...";                          // result = result + "..."; 와 같다.
```

<br>

<br>

### 4) 커맨드 라인을 통해 입력받기

Scanner클래스의 nextLine()외에도 화면을 통해 사용자로부터 값을 입력받을 수 있는 간단한 방법이 있다. 바로 커맨드라인을 이요한 방법인데, 프로그램을 실행할 때 클래스 이름 뒤에 공백문자로 구분하여 여러 개의 문자열을 프로그램에 전달할 수 있다.

커맨드라인을 통해 입려된 두 문자열을 String배열에 담겨서 MainTest클래스의 main메서드의 매개변수(args)에 전달된다. 그리고는 main메서드 내에서 args[0], args[1]과 같은 방식으로 커맨드라인으로 부터 전달받은 문자열의 접근할 수 있다. 여기서 args[0]은 "abc"이고 args[1]은 "123"이 된다.

커맨드라인에 입력된 매개변수는 공백문자로 구분하기 때문에 입력될 값에 공백이 있는 경우 큰 따옴표(")로 감싸주어야 한다. 그리고 커맨드라인에서 숫자를 입력해도 숫자가 아닌 문자열로 처리된다는 것에 주의해야 한다.

문자열 "123"을 숫자 123으로 바꾸려면 다음과 같이 한다.

```java
int num = Integer.parseInt("123");  // 변수 num에 숫자 123이 저장된다.
```

<br>

그리고 커맨드라인에 매개변수를 입력하지 않으면 크기가 0인 배열이 생성되어 args.length의 값은 0이 된다. 만일 입력된 매개변수가 없다고 해서 배열을 생성하지 않으면 참조변수 args의 값은 null이 될 것이고, 배열 args를 사용하느 모든 코드에서 에러가 발생할 것이다. 이러한 에러를 피하려면, 다음과 같이 main 메서드에 if문을 추가해줘야 한다.

```java
public static void main(String[] args) {
		if (args != null) { // args가 null이 아닐 때만 괄호{}의 문자들을 수행
			System.out.println("매개변수의 개수: " + args.length();
			for (int i = 0; i < args.length; i++) {
				System.out.println("args[" + i + "]"  = \"" + args[i] + "\"");
			}
		}
}
```

그러나 JVM이 입력된 매개변수가 없을 때, null 대신 크기가 0인 배열을 생성해서 args에 전달하도록 구현되어 우리는 이러한 수고를 덜게 되었다.

<br>

<br>

<br>

## 3. 다차원 배열

---

### 1) 2차원 배열의 선언과 인덱스

**2차원 배열의 선언**

| 선언 방법            | 선언 예          |
| -------------------- | ---------------- |
| `타입[][] 변수이름`: | `int[][] score;` |
| `타입 변수이름[][]`: | `int socre[][];` |
| `타입[] 변수이름[]`: | `int[] score[];` |

<br>

2차원 배열은 주로 테이블 형태의 데이터를 담는데 사용되며, 만일 4행 3열의 데이터를 담기 위한 배열을 생성하려면 다음과 같이 한다.

```java
int[][] score = new int[4][3]; // 4행 3열의 2차원 배열을 생성한다.
```

<br>

<br>

### 2차원 배열의 index

2차원 배열은 행(row)과 열(column)로 구성되어 있기 때문에 index도 행과 열에 각각 하나씩 존재한다.

- '행 index'의 범위 : `0~행의 길이 -1`
- '열 index'의 범위 : `0~열의 길이 -1`

배열 score의 1행 1열에 100을 저장하고, 이 값을 출력하려면 다음과 같이 하면 된다.

```java
socre[0][0] = 100;                // 배열 score의 1행 100을 저장
System.out.println(score[0][0]);  // 배열 score의 1행 1열의 값을 출력
```

<br>

<br>

### 2) 2차원 배열의 초기화

2차원 배열도 괄호{}를 사용해서 생성과 초기화를 동시에 할 수 있다. 다만, 1차원 배열보다 괄호{}를 한번 더 써서 행렬로 구분해 준다.

```java
int[][] arr = new int[][] { { 1, 2, 3 }, { 4, 5, 6 } };
int[][] arr = { { 1, 2, 3 }, { 4, 5, 6 } };  // new int[][]가 생략됨
```

<br>

만일 for문을 이용해서 2차원 배열을 초기화한다면 다음과 같을 것이다.

```java
for (int i = 0; i < **score.length**; i++) {
		for (int j = 0; j < **score[i].length**; j++) {
				score[i][j] = 10;
		}
}
```

<br>

<br>

### 3) 가변 배열

자바에서는 2차원 이상의 배열을 '배열의 배열' 의 형태로 처리한다는 사실을 이용하면 보다 자유로운 형태의 배열을 구성할 수 있다.

2차원 이상의 다차원 배열을 생성할 때 전체 배열 차수 중 마지막 차수의 길이를 지정하지 않고, 추후에 각기 다른 길이의 배열을 생성함으로써 고정된 형태가 아닌 보다 유동적인 가변 배열을 구성할 수 있다.

```java
int[][] score = new int[5][3];  // 5행 3열의 2차원 배열 생성
```

<br>

위 코드를 다음과 같이 표현할 수 있다.

```java
int[][] score = new int[5][];  // 두 번째 차원의 길이는 지정하지 않는다.
score[0] = new int[3];
score[1] = new int[3[;
score[2] = new int[3];
score[3] = new int[3];
score[4] = new int[3];
```

<br>

첫 번째 코드와 같이 2차원 배열을 생성하면 직사각형 테이블 형태의 고정적인 배열만 생성할 수 있지만, 두 번째 코드와 같이 2차원 배열을 생성하면 다음과 같이 각 행마다 다른 길이의 배열을 생성하는 것이 가능하다.

```java
int[][] score = new int[5][];
score[0] = new int[4];
score[1] = new int[3];
score[2] = new int[2];
score[3] = new int[2];
score[4] = new int[3];
```

<br>score.length의 값은 여전히 5지만, 일반적인 2차원 배열과 달리 score[0].lengh의 값은 4이고 score[1].length의 값은 3으로 서로 다르다.

```java
int[][] score = {
										{100, 100, 100, 100}
									, {20, 20, 20}
									, {30, 30}
									, {40, 40}
									, {50, 50, 50}
							};
```