## 1. 연산자 (Operator)

---

연산자는 `연산을 수행하는 기호` 를 말한다.

<br>

### 1) 연산자와 피연산자

- 연산자(Operator) : 연산을 수행하는 기호(+, -, *, / 등)
- 피연산자(Operand) : 연산자의 작업 대상(변수, 상수, 리터럴, 수식)

```java
x + 3

// + : 연산자
// x, 3 : 피연산자
```

연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.

<br>

### 2) 식과 대입연산자

연산자와 피연산자를 조합하여 계산하고자하는 바를 표현한 것을 `식(expression)` 이라고 한다. 그리고 식을 계산하여 결과를 얻는 것을 `식을 평가(evaluation)한다` 고 한다.

하나의 식을 평가(계산)하면, 단 하나의 결과를 얻는다. 

```java
4 * x + 3; // 문장(statement)
```

<br>

예를 들어 변수 x의 값이 5일 때, 위의 문장은 다음과 같은 과정으로 처리한다.

```java
4 * x + 3;
-> 4 * 5 + 3;
-> 23;        // 결과를 얻었지만 쓰이지 않고 사라진다.
```

<br>

<br>

### 3) 연산자의 종류

**연산자의 기능별 분류**

| 종류        | 연산자                              | 설명                                         |
| ----------- | ----------------------------------- | -------------------------------------------- |
| 산술 연산자 | `+`,` -`,` *`,` /`, `%`,` <<`,` >>` | 사칙 연산(+,-,*,/)과 나머지 연산(%)          |
| 비교 연산자 | `>`,` <`,` ≥`,` ≤`,` ==`,` ≠`       | 크고 작음과 같고 다름을 비교                 |
| 논리 연산자 | `&&`, `||`, `!`, `&`, `|`, `^`, `~` | '그리고(AND)'와 '또는(OR)'으로 조건을 연결   |
| 대입 연산자 | `=`                                 | 우변의 값을 좌변에 저장                      |
| 기타        | `(type) ? : instanceof`             | 형변환 연산자, 삼항 연산자, instanceof연산자 |



<br>

<br>

### 피연산자의 개수에 의한 분류

피연산자의 개수로 연산자를 분류하기도 하는데, 피연산자의 개수가 하나면 '단항 연산자', 두 개면 '이항 연산자', 세 개면 '삼항 연산자' 라고 부른다. 대부분의 연산자는 '이항 연산자' 이고, 삼항 연산자는 오직 `? :` 하나 뿐이다.

```java
-3-5
// 첫 번째 - <- 부호 연산자
// 두 번째 - <- 뺄셈 연산자
```

<br>

이처럼 서로 다른 연산자의 기호가 같은 경우도 있는데, 이럴 때는 피연산자의 개수로 구분이 가능하다.

```java
-3-5
// 뺄셈 연산자의 피연산자 -3, 5
// 부호 연산자의 피연산자 3
```

부호 연산자는 단항 연산자로 피연산자가 '3' 한 개뿐이지만, 뺄셈 연산자는 이항 연산자로 피연산자가 '-3'과 '5' 두 개이다.

이처럼 연산자를 기능별, 피연산자의 개수별로 나누어 분류하는 것은 곧이어 배우게 될 `연산자의 우선순위` 때문이기도 하다. 연산자마다 우선수위가 다르지만, 같은 종류의 연산자들은 우선순위가 비슷하기 때문에 각 종류별로 우선순위를 외우면 기억하기 쉽다.

<br>

<br>

### 4) 연산자의 우선순위와 결합규칙

식에 사용된 연산자가 둘 이상인 경우, 연산자의 우선순위에 의해서 연산순서가 결정된다. 곱셈과 나눗셈(*, /)은 덧셈과 뺄셈(+, -)보다 우선순위가 높다는 것은 이미 수학에서 배워서 알고 있을 것이다. 그래서 아래의 식은 '3 * 4' 가 먼저 계산된 다음, 그 결과에 5를 더해서 17을 결과로 얻는다.

```java
5 + 3 * 4
=> 3 * 4 = 12
=> 5 + 12 = 17
```

<br>

**우선순위의 예외 설명**

| 식                  | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| -x + 3              | 단항 연산자가 이항 연산자보다 우선순위가 높다. <br />그래서 x의 부호를 바꾼 다음 덧셈이 수행된다. 여기서 '-'는 뺄셈 연산자가 아니라 부호 연산자이다. |
| x + 3 * y           | 곱셈과 나눗셈이 덧셈과 뺼셈보다 우선순위가 높다. <br />그래서 '3 * y'가 먼저 계산된다. |
| x + 3 > y -2        | 비교 연산자(>)보다 산술 연산자 '+'와 '-'가 먼저 수행된다.<br /> 그래서 'x + 3'과 'y-2'가 먼저 계산된 다음에 '>'가 수행된다. |
| x > 3 && x < 5      | 논리 연산자 '&&'보다 비교 연산자가 먼저 수행된다. <br />그래서 'x > 3'와 'x < 5'가 먼저 계산된 다음에 '&&'가 수행된다.<br /> 식의 의미는 'x가 3보다 크고 5보다 작다'이다. |
| result = x + y * 3; | 대입 연산자는 연산자 중에서 제일 우선순위가 낮다.<br /> 그래서 우변의 최정 연산겨로가가 변수 result에 저장된다. |



<br>

<br>

**주의해야 할 연산자 우선순위의 예와 설명**

| 식                         | 설명                                                         |
| -------------------------- | ------------------------------------------------------------ |
| x << 2 + 1                 | 쉬프트 연산자(<<)는 덧셈 연산자보다 우선순위가 낮다.<br /> 그래서 왼쪽의 식은 'x << (2 +1)'과 같다. |
| data & 0xFF == 0           | 비트 연산자(&)는 비교 연산자(==)보다 우선순위가 낮으며 비교연산후에 비트연산이 수행된다. <br />그래서 왼쪽의 식은 'data & (0xFF ==0)'과 같다. |
| x < -1 \|\| x > 3 && x < 5 | 논리 연산자 중에서 AND를 의미하는 '&'와 '&&'가 OR를 의미하는 '\|' 와 '\|\|' 보다 우선순위가 높다.<br />이처럼 수식에 AND와 OR가 함께 사용되는 경우는 다음과 같이 괄호를 사용해서 우선순위를 명확히 하는 것이 좋다.<br />x < -1 \|\| (x > 3 && x < 5) |

<br>

> 괄호는 연산자가 아니다. 연산자의 우선순위를 임의로 지정할 때 사용하는 기호일 뿐이다.
> 

<br>

<br>

### 연산자의 결합규칙

하나의 식에 같은 우선순위의 연산자들이 여러 개 있는 경우, 어떤 순서로 수행할까? 우선순위가 같다고 해서 아무거나 먼저 처리하는 것은 아니고 나름대로의 규칙을 가지고 있는데, 그 규칙을 `연산자의 결합규칙` 이라고 한다.

연산자의 결합규칙은 연산잗마다 다르지만, 대부분 왼쪽에서 오른쪽의 순서로 연산을 수행하고, 단항 연산자와 대입 연산자만 그 반대로, 오른쪽에서 왼쪽의 순서로, 연산을 수행한다.

```java
// 연산자의 결합규칙이 왼쪽에서 오른쪽인 경우
// -------->
3 + 4 - 5

// 연산자의 결합규칙이 오른쪽에서 왼쪽인 경우
// <--------
x = y = 3
// x = 3
// 3
```

1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연사자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.

<br>

<br>

<br>

### 5) 산술 변환(usual arithmetic conversion)

이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로, 피연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로 타입을 일치시켜야한다. 예를 들어 int타입과 float타입을 덧셈하는 경우, 형변환 연산자를 사용해서 피연산자의 타입을 둘 다 int 또는 float로 일치시켜야 한다.

```java
int i = 10;
float f = 20.0f;
float result = f + (float)i; // 형변환으로 두 피연산자의 타입을 일치
```

<br>

대부분의 경우, 두 피연산자의 타입 중에서 더 큰 타입으로 일치시키는데, 그 이유는 작은 타입으로 형변환하면 원래의 값이 손실될 가능성이 있기 때문이다. 앞에서 배운 것과 같이 작은 타입에서 큰 타입으로 형변환하는 경우, 자동적으로 형변환되므로 형변환 연산자를 생략할 수 있다.

```java
float result = f + i; // 큰 타입으로 형변환시, 형변환연산자 생략가능
```

이처럼 연산 전에 피연산자 타입의 일치를 위해 자동 현변환되는 것을 '산술 변환' 또는 '일반 산술 변환'이라 하며, 이 변환은 이항 연산에서만 단항 연산에서도 일어난다.

**두 피연산자의 타입을 길게 일치시킨다. (보다 큰 타입으로 일치)**

```java
long   + int   --> long   + long   --> long
float  + int   --> float  + float  --> float
double + float --> double + double --> double
```

<br>

**피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.**

```java
byte + short --> int + int --> int
char + short --> int + int --> int
```

첫 번째 규칙은 앞서 자동 형변환에서 배운 것처럼 피연산자의 값손실을 최소화하기 위한 것이고, 두 번째 규칙은 정수형의 기본 타입인 int가 가장 효율적으로 처리할 수 있는 타입이기 때문에, 그리고 int보다 작은 타입, 예를 들면 char이나 short의 표현범위가 좁아서 연산중에 오버플로우(overflow)가 발생할 가능성이 높기 때문에 만들어진 것이다.

<br>

연산결과의 타입은 피연산자의 타입과 일치한다. 예를 들어 int와 int의 나눗셈 연산결과는 int이다. float과 double과 같은 실수형이 아니기 때문에 소수점 이하는 버려진다. 그래서 아래의 식 '5 나누기 2'의 결과가 2.5가 아닌 2이다.

```java
int / int --> int
5   / 2   --> 2
```

<br>

위의 식에서 2.5라는 실수를 결과로 얻으려면, 피연산자 중 어느 한 쪽을 float와 같은 실수형으로 형변환해야 한다. 그러면, 다른 한 쪽은 산술 변환의 첫 번째 규칙에 의해 자동적으로 형변환되어 두 피연산자 모두 실수형이 되고, 연산결과 역시 실수형의 값을 얻을 수 있다.

```java
int / (float)int --> int
5   / (float)2   --> 5

float / float --> float
5.0f  / 2.0f  --> 2.5f
```

산술 변환이란? 연산 수행 직전에 발생하는 피연산자의 자동 형변환

1. 두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)
2. 피연산자의 타입의 int보다 작은 타입이면 int로 변환된다.

<br>

<br>

<br>

## 2. 단항 연산자

---

### 1) 증감 연산자 ++ —

증감연산자는  피연산자에 저장된 값을 1 증가 또는 감소시킨다. 증감연산자의 피연산자로 정수와 실수가 모두 가능하지만, 상수는 값을 변경할 수 없으므로 가능하지 않다.

<br>

> 증감연산자는 일반 산술 변환에 의한 자동 형변환이 발생하지 않으며, 연산결과의 타입은 피연산자의 타입과 같다.
> 

```java
증감 연산자(++) 피연산자의 값을 1 증가시킨다.
감소 연산자(--) 피연산자의 값을 1 감소시킨다.
```

<br>

일반적으로 단항 연산자는 피연산자의 왼쪽에 위치하지만, 증가 연산자 '++'와 감소 연산자 '—'는 양쪽 모두 가능하다. 피연산자의 왼쪽에 위치하면 `전위형(prefix)` , 오른쪽에 위치하면 `후위형(postfix)` 이라고 한다.

**전위형과 후위형의 비교**

| 타입   | 설명                             | 사용예   |
| ------ | -------------------------------- | -------- |
| 전위형 | 값이 참조되기 `전에` 증가시킨다. | j = ++i; |
| 후위형 | 값이 참조된 `후에` 증가시킨다.   | j = i++; |



<br>

그러나 '++i;'와 'i++;' 처럼 증감연산자가 수식이나 메서드 호출에 포함되지 않고 독립적인 하나의 문장으로 쓰인 경우에는 전위형과 후위형의 차이가 없다.

```java
++i;  // i의 값을 1 증가시킨다. 
i++;  // 위의 문장과 차이가 없다.
```

<br>

이 경우에는 어떤 수식이 포함된 것이 아니라 단독적으로 사용도니 것이기 때문에, 증감연산자(++)를 피연산자의 왼쪽에 사용한 경우(전위형, ++i)와 오른쪽에 사용한 경우(후위형, i++)의 차이가 없다. 

그러나 다른 수식에 포함되거나 메서드의 매개변수로 사용된 경우, 즉 단독으로 사용되지 않은 경우 전위형(++i)과 후위형(j++)의 결과는 다르다.

<br>

실행결과를 보면 i의 값은 두 경우 모두 1이 증가되어 6이 되지만, j의 값은 그렇지 않다.

```java
i = 5, j = ++i;
// 1. i의 값을 증가
// 2. i의 값을 참조
// 3. 연산결과를 j에 저장

i = 5, j = i++;
// 1. i의 값을 참조
// 2. 연산결과를 j에 저장
// 3. i의 값을 증가 
```

<br>

증감 연산자가 포함된 식을 이해하기 어려울 때는 다음과 같이 증감 연산자를 따로 떼어내면 이해하기가 쉬워진다.

```java
j = ++i;   // 전위형
--> ++i;   // 증가 후에
--> j = i; // 참조하여 대입
```

<br>

후위형의 경우 증감연산자를 식의 이후로 떼어내면 된다.

```java
j = i++; // 후위형
j = i;   // 참조하여 대입 후에
i++;     // 증가
```

<br>

i는 값이 증가되기 전에 참조되므로, println()에게 i에 저장된 값 5를 넘겨주고 나서 i의 값이 증가하기 때문에 5가 출력되고, j의 경우 j에 저장된 값을 증가 시킨 후에 println()에게 값을 넘겨주므로 6이 출력된다.

<br>

증감연산자를 따로 떼어내면 같은 코드가 된다.

```java
System.out.println(i++);
System.out.println(++j);
```

```java
System.out.println(i);
i++;
++j;
System.out.println(j);
```

<br>

증감연산자를 사용하면 코드가 간결해지지만, 지나치면 코드가 복잡해서 이해하기 어려워지기도 한다.

```java
x = x++ - ++x;
```

하나의 식에서 증감연산자의 사용을 최소화하고, `식에 두 번 이상 포함된 변수에 증감연산자를 사용하는 것은 피해야 한다.`

<br>

<br>

### 2) 부호 연산자 + -

부호 연산자 '-'는 피연산자의 부호를 반대로 변경한 결과를 반환한다. 부호 연산자는 boolean형과 char형을 제외한 기본형에만 사용할 수 있다.

> 부호연산자는 덧셈, 뺄셈연산자와 같은 기호를 쓰지만 다른 연산자이다. 기호는 같아도 피연산자와 개수가 달라져 구별이 가능하다.
> 

<br>

<br>

<br>

## 3. 산술 연산자

---

산술 연산자에는 사칙 연산자(+, -, *, /)와 나머지 연산자(%)가 있다.

<br>

<br>

### 1) 사칙 연산자 + - * /

두 변수 a와 b에 각각 10과 4를 저장하여 사칙연산을 수행하고 그 결과를 출력하는 예제이다. 여기서 눈여겨볼 것은 10을 4로 나눈 결과가 2.5가 아닌 2라는 것이다.

```java
int / int --> int
10  / 4   --> 2   // 소수점 이하는 버려진다.
```

<br>

나누기 연산자의 두 핀연산자가 모두 int타입인 경우, 연산결과 역시 int타입이다. 그래서 실제 연산결과는 2.5일지라도 int타입의 값만 2를 결과로 얻는다. 이 때, 반올림이 발생하지 않는다는 것에 주의하자. 그래서 올바른 연산결과를 얻기 위해서는 두 피연산자 중 어느 한 쪽을 실수형으로 형변환해야 한다. 그래야만 다른 한 쪽도 같이 실수형으로 자동 형변환되어 결국 실수형의 값을 결과로 얻는다.

```java
int  float       float   float       float
10 / 4.0f ---->  10.0f / 4.0f  ----> 2.5f
```

위의 연산과정을 보면, 두 피연산자의 타입이 일치하지 않으므로 int타입보다 범위가 넓은 float 타입으로 일치시킨 후에 연산을 수행하는 것을 알 수 있다.

```java
System.out.println(3/0);   // 실행하면, 오류(ArithmeticException) 발생
System.out.println(3/0.0); // Infinity가 출력됨
```

<br>

크기가 작은 자료형의 변수를 큰 자료형의 변수에 저장할 때는 자동으로 형변환(jtype conversion, casting)되지만, 반대로 큰 자료형의 값을 자근 자료형의 변수에 저장하려면 명시적으로 형변환 연산자를 사용해서 변환해주어야 한다.

<br>

'a * b'의 결과 값을 담는 변수 c의 자료형이 long타입(8 byte)이기 때문에 저장하기 충분하므로 '20000000000' 이 출력될 것 같지만, 결과는 전혀 다른 값이 출력된다.

<br>

그 이유는 int타입과 int타입의 연산결과는 int타입이기 때문이다.

<br>

사칙연산의 피연산자로 숫자뿐만 아니라 문자도 가능하다. 문자는 실제로 해당 문자의 유니코드(부호없는 정수)로 바뀌어 저장되므로 문자간의 사칙연산은 정수간의 연산과 동일하다. 주로 문자간의 뺄셈을 하는 경우가 대부분이며, 문자 "2"를 숫자로 변환하려면 다음과 같이 문자 '0'을 뺴주면 된다.

```java
'2' -> '0' -> 50 - 48 -> 2
```

```java
// 컴파일 전의 코드
char c2 = 'a' + 1;
int sec = 60 * 60 * 24;

// 컴파일 후의 코드
char c2 = 'b';
int sec = 86400;
```

<br>

수식에 변수가 들어가 있는 경우에는 컴파일러가 미리 계산을 할 수 없기 때문에 형변환을 해주어야 한다. 그렇지 않으면 컴파일 에러가 발생한다.

```java
char c2 = c1 + 1; --->
char c2 = (char)(c1 + 1);
```

<br>

일부러 뻔 한 리터럴 연산을 풀어쓸 필요는 없지만, 코드의 가독성과 유지보수를 위해서 그렇게 하는 경우가 있다.

<br>

round 메서드는 매개변수로 받은 값을 소수점 첫째자리에서 반올림을 하고, 그 결과를 정수로 돌려주는 메서드이다.

```java
Math.round(pi * 1000) / 1000.0
-> Math.round(3.141592 * 1000) / 1000.0
-> Math.round(3141.592) / 1000.0
-> 3142 / 1000.0
-> 3.142
```

<br>

<br>

### 2) 나머지 연산자 %

나머지 연산자는 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자이다.

그리고 나눗셈에서처럼 나누는 수(오른쪽 피연산자)로 0을 사용할 수 없다는 점을 주의하자.

나머지 연산자는 주로 `짝수, 홀수 또는 배수 검사 등에 주로 사용된다.`

<br>

나머지 연산자(%)는 나누는 수로 음수도 허용한다. 그러나 부호는 무시되므로 결과는 음수의 절대값으로 나눈 나머지와 결과가 같다.

```java
System.out.println(10 % 8);  // 10을 8로 나눈 나머지 2가 출력된다.
System.out.println(10 % -8); // 위와 같은 결과를 얻는다.
```

그냥 피연산자의 부호를 모두 무시하고, 나머지 연산을 한 결과에 왼쪽 피연산자(나눠지는 수)의 부호를 붙이면 된다.

<br>

<br>

## 4. 비교 연산자

---

비교 연산자는 두 피연산자를 비교하는 데 사용되는 연산자다. 주로 `조건문과 반복문의 조건식에 사용되며`, 연산결과는 오직 `true`와 `false` 둘 중의 하나이다.

비교 연산자 역시 이항 연산자이므로 비교하는 피연산자의 타입이 서로 다를 경우에는 자료형의 범위가 큰 쪽으로 형변환하여 피연산자의 타입을 일치시킨 후에 비교한다는 점의 주의하자.

<br>

### 1) 대소비교 연산자 <  >  ≤  ≥

**대소비교연산자의 종류와 연산결과**

| 비교연산자 | 연산결과                                     |
| ---------- | -------------------------------------------- |
| >          | 좌변 값이 `크면`, true 아니면 false          |
| <          | 좌변 값이 `작으면`,  true 아니면 false       |
| >=         | 좌변 값이 `크거나 같으면`, true 아니면 false |
| <=         | 좌변 값이 `작거나 같으면`, true 아니면 false |



<br>

<br>

### 2) 등가비교 연산자 ==  ≠

**등가비교연산자의 종류와 연산결과**

| 비교연산자 | 연산결과                            |
| ---------- | ----------------------------------- |
| ==         | 두 값이 `같으면`, true 아니면 false |
| !=         | 두 값이 `다르면`, true 아니면 false |



<br>

비교 연산자도 이항 연산자이므로 연산을 수행하기 전에 형변환을 통해 두 피연산자의 타입을 같게 맞춘 다음 피연산자를 비교한다.

```java
10 == 10.0f
-> 10.0f == 10.0f
-> true
```

<br>

문자 'A'의 유니코드는 10진수로 65이고, 'B'는 66, '0'은 48이므로 나머지 식들은 다음과 같은 과정으로 연산된다.

```java
'0' == 0 --> 48 == 0 --> false
'A' == 65 -- > 65 == 65 --> true
'A' > 'B' --> 65 > 66 --> false
'A' + 1 != 'B' --> 65 + 1 != 66 --> 66 != 66 --> false
```

<br>

결과를 보고 다소 혼란스러울 것이다. "10.0 == 10.0f"는 true인데, "0.1 == 0.1f"는 false라니 이해하기 어려울 것이다. 그것은 정수형과 달리 실수형은 근값으로 저장되므로 오차가 발생할 수 있기 때문이다.

```java
float  f = 01.f; // f에 0.10000000149011612로 저장된다.
double d = 0.1;  // d에 0.10000000000000001로 저장된다.
```

<br>

<br>

### 문자열의 비교

두 문자열을 비교할 때는, 비교 연산자 '==' 대신 equals()라는 메서드를 사용해야 한다.

비교 연산자는 두 문자열이 완전히 같은 것인지 비교할 뿐이므로, 문자열의 내용이 같은지 비교하기 위해서는 equals()를 사용하는 것이다.

```java
String str = new String("abc");

// equals()는 두 문자열의 내용이 같으면 true, 다르면 false
boolean result = str.equals("abc"); // 내용이 같으므로 result에 true가 저장됨
```

<br>

원래 String은 클래스이므로, `new` 를 사용해서 객체를 생성해야 한다.

```java
String str = new String("abc"); // String 클래스의 객체를 생성
String str = "abc";             // 위의 문장을 간단히 표현
```

<br>

str2와 "abc"의 내용이 같은데도 '=='로 비교하면, false를 결과로 얻는다. 내용은 같지만 서로 다른 객체라서 그렇다. 그러나 equals()는 객체가 달라도 내용이 같으면 `true` 를 반환한다. 그래서 문자열을 비교할 때는 항상 equals()를 사용해야 한다는 것을 기억하자.

<br>

만일 대소문자를 구분하지 않고 비교하고 싶으면, equals() 대신 `equalsIgnoreCase()` 를 사용하면 된다.

<br>

<br>

<br>

## 5. 논리 연산자

---

논리 연산자는 둘 이상의 조건을 `'그리고(AND)'` 나 `'또는(OR)'` 으로 연결하여 하나의 식으로 표현할 수 있게 해준다.

<br>

### 1) 논리 연산자 - &&, ||, !

```java
|| (OR결합)  피연산자 중 어느 한 쪽만 true이면 true를 결과로 얻는다.
&& (AND결합) 피연산자 양쪽 모두 true이어야 true를 결과로 얻는다.
```

<br>

**논리 연산자의 연산결과**

| x     | y     | x \|\| y | x && y |
| ----- | ----- | -------- | ------ |
| true  | true  | true     | true   |
| true  | false | true     | false  |
| false | true  | true     | false  |
| false | false | false    | false  |



<br>

**x는 10보다 크고, 20보다 작다**

```java
10 < x && x < 20
```

<br>

**i는 2의 배수 또는 3의 배수이다.**

```java
i % 2 == 0 || i % 3 ==0
```

<br>

**i는 2의 배수 또는 3의 배수지만 6의 배수는 아니다.**

```java
(i % 2 == 0 || i % 3 == 0) && i % 6 != 0
```

<br>

**문자 ch는 숫자('0' ~ '9')이다.**

```java
'0' <= ch && ch <= '9'
```

<br>

**문자 ch는 대문자 또는 소문자이다.**

```java
('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')
```

<br>

<br>

### 효율적인 연산(short circuit evaluation)

논리 연산자의 또 다른 특징은 효율적인 연산을 한다는 것이다.

OR연산 '||' 의 경우, 두 피연산자 중 어느 한 쪽만 '참'이어도 전체 연산결과가 '참'이므로 좌측 피연산자가 'true(참)' 이면, 우측 피연산자의 값은 평가하지 않는다.

<br>

**x가 true이면, x || y는 항상 true이다.**

| x     | y     | x \|\| y |
| ----- | ----- | -------- |
| true  | true  | true     |
| true  | false | true     |
| flase | true  | true     |
| false | false | false    |



<br>

AND연산 '&&'의 경우도 마찬가지로 어느 한쪽만 '거짓(false)'이어도 전체 연산결과가 '거짓(false)' 이므로 좌측 피연산자가 '거짓(false)'이면, 우측 피연산자는 평가하지 않는다.

<br>

**x가 false이면, x && y는 항상 false이다.**

| x     | y     | x && y |
| ----- | ----- | ------ |
| true  | true  | true   |
| true  | false | false  |
| false | true  | false  |
| false | false | false  |



<br>

그래서 같은 조건식이라도 피연산자의 위치에 따라서 연산속도가 달라질 수 있는 것이다.

OR연산 '||'의 경우에는 연산결과가 '참'일 확률이 높은 피연산자를 연산자의 왼쪽에 놓아야 더 빠른 연산결과를 얻을 수 있다.

```java
('a' < = ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')
```

<br>

이 식에서 문자 ch가 소문자인 조건을 대문자인 조건보다 왼쪽에 놓았다. 그 이유는 사용자로부터 문자 ch를 입력받을 때, 사용자가 대문자보다 소문자를 입력할 확률이 높다고 판단했기 때문이다. 실제로 사용자가 소문자를 더 자주 입력한다면, 이 식은 더 효율적으로 처리될 것이다.

<br>

두 변의 논리연산 후에도 b의 값은 여전히 0인 채로 남아있다. '||(OR)'의 경우는 좌측 피연산자(a != 0)가 참이라서, 그리고 '&&(AND)'의 경우는 좌측 피연산자(a == 0)가 거짓이라서 우측 피연산자를 평가하지 않았기 떄문이다.

<br>

<br>

### 논리 부정 연산자 !

<br>

**논리 부정 연산자의 연산결과**

| x     | !x    |
| ----- | ----- |
| true  | false |
| false | true  |



<br>

<br>

### 2) 비트 연산자 &  |  ^  ~ << >>

비트 연산자는 피연사자를 비트단위로 논리 연산한다. 피연산자를 이진수로 표현했을 때의 각 자리를 아래의 규칙에 따라 연산을 수행하며, 피연산자로 실수는 허용하지 않는다. 정수(문자 포함)만 허용된다.

```java
| (OR연산자)  피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 그 외에는 0을 얻는다.
& (AND연산자) 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다.
^ (XOR연산자) 피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 같을 때는 0을 얻는다.
```

<br>

**비트 연산자의 연산결과**

> 연산자 '^'는 배타적 XOR(eXclusive OR)라고 하며, 피연산자의 값이 서로 다른 경우, 즉 배타적인 경우에만 참(1)을 결과로 얻는다.
> 

<br>

비트연산에서도 피연산자의 타입을 일치시키는 `산술 변환` 이 일어날 수 있다.

<br>

<br>

### 비트 전환 연산자 ~

이 연산자는 피연산자를 2진수로 표현했을 때, 0은 1로, 1은 0으로 바꾼다. 논리부정 연산자 `!` 와 유사하다.

<br>

**비트전환 연산자의 2진 연산결과**

| x    | -x   |
| ---- | ---- |
| 1    | 0    |
| 0    | 1    |



<br>

비트 전환 연산자 '~'에 의해 `비트 전환` 되고 나면, 부호있는 타입의 피연산자는 부호가 반대로 변경된다.

즉, , 피연산자의 '1의 보수'를 얻을 수 있는 것이다. 그래서 비트전환연산자를 `1의 보수` 연산자 라고 한다.

```java
// 2진수
0 0 0 0 1 0 1 0
1 1 1 1 0 1 0 1

// 10진수
10
-11
```

<br>

예를 들어 10진수 10을 비트전환 연산한 결과는 -11이고, 이 값은 10의 '1의 보수' 이다. 

1의 보수에 1을 더하면 음수가 되므로 -11에 1을 더하면 -10이 되고 -11은 10의 '1의 보수'가 맞는 것을 확인할 수 있다.

```java
// 2진수            // 10진수
0 0 0 0 1 0 1 0        10
1 1 1 1 0 1 0 1       -11
1 1 1 1 0 1 0 1       -11
0 0 0 0 0 0 0 1    +1   1
1 1 1 1 0 1 1 0       -10
```

<br>

'~~p'는 변수 p에 비트 전환 연산을 두 번 적용한 것인데, 1을 0으로 바꿨다가 다시 0을 1로 바꾸므로 원래의 값이된다. 그러나 연산결과의 타입이 byte가 아니라 int라는 것에 주의하자.

<br>

<br>

### 쉬프트 연산자  <<  >>

이 연산자는 피연산자의 각 자리(2진수로 표현했을 때)를 `오른쪽(>>)` 또는 `왼쪽(<<)` 으로 이동(shift)한다고 해서 `쉬프트 연산자(shift operator)` 라고 이름 붙여졌다.

예를 들어 '8 << 2'는 왼쪽 피연산자인 10진수 8의 2진수를 왼쪽으로 2자리 이동한다. 이 떄, 자리이동으로 저장범위를 벗어난 값들은 버려지고 빈자리는 0으로 채워진다.

```java
x << n은 x * 2^n의 결과와 같다.
x >> n은 x / 2^n의 결과와 같다.
```

곱셈이나 나눗셈 연산자를 사용하면 같은 결과를 얻을 수 있는데, 굳이 쉬프트 연산자를 제공하는 이유는 무엇일까? 그 이유는 속도 때문이다.

'<<' 연산자를 사용하는 것이 나눗셈 '/' 또는 곱셈 '*' 연산자를 사용하는 것 보다 더 빠르다.

그러나 프로그램의 실행속도도 중요하지만 프로그램을 개발할 때 코드의 가독성(readability)도 중요하다.

쉬프트 연산자가 속도가 빠르긴 해도 곱셈이나 나눗셈 연산자 보다는 가독성이 떨어질 것이다.

`쉬프트 연산자보다 곱셈 또는 나눗셈 연산자를 주로 사용하고, 보다 빠른 실행속도가 요구되어지는 곳만 쉬프트 연산자를 사용하는 것이 좋다.`

<br>

<br>

<br>

## 6. 그 외의 연산자

---

### 1) 조건 연산자 ? :

조건 연산자는 조건식, 식1, 식2 모두 세 개의 피연산자를 필요로 하는 삼항 연산자이며,

삼항 연산자는 조건 연산자 하나뿐이다.

```java
조건식 ? 식1 : 식2

// 참(treu)
식1
// 거짓(false)
식2
```

<br>

가독성을 높이기 위해 조건식을 괄호()로 둘어싸는 경우가 많지만 필수는 아니다.

```java
result = (x > y) ? x : y;
```

<br>

만일 x의 값이 5, y의 값이 3이라면, 이 식은 다음과 같은 과정으로 계산된다.

```java
result = (x > y) ? x : y;
-> result = (5 > 3) ? 5 : 3;
-> result = (true) ? 5 : 3; // 조건식이 true(참) 이므로 연산결과는 5
-> result = 5;
```

<br>

조건 연산자는 조건문인 if문으로 바꿔 쓸 수 있으며, if문 대신 조건 연산자를 사용하면 코드를  보다 간단히 할 수 있다.

조건 연산자를 중첩해서 사용하면 셋 이상 중의 하나를 결과로 얻을 수 있다.

```java
result = x > 0 ? 1 : (x == 0 ? 0 : -1);
--> result = x > 0 ? 1 : (3 == 0 ? 0 : -1);
--> result = x > 0 ? 1 : (false ? 0 : -1); // 조건식이 false이므로, 연산결과는 식2
--> result = 3 > 0 ? 1 : -1;
--> result = true ? 1 : -1; // 조건식이 true 이므로, 연산결과는 식1
--> result = 1;

```

<br>

조건 연산자를 여러 번 중첩하면 코드가 간략해지긴 하지만, 가독성이 떨어지므로 꼭 필요한 경우에 한번 정도만 중첩하는 것이 좋다.

<br>

<br>

### 2) 대입 연산자  =  op==

대입 연산자는 변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장하는데 사용된다.

이 연산자는 오른쪽 피연산자의 값(식이라면 평가값)을 왼쪽 피연산자에 저장한다. 그리고 저장된 값을 연산결과로 반환한다.

```java
System.out.println(x = 3); // 변수 x에 3이 저장되고
-> System.out.println(3);  // 연산결과인 3이 출력된다.
```

<br>

대입 연산자는 연산자들 중에서 가장 낮은 우선순위를 가지고 있기 때문에 식에서 제일 나중에 수행된다.

그리고 앞서 배운 것처럼 연산 진행 방향이 오른쪽에서 왼쪽이기 떄문에 'x = y = 3;' 에서 'y = 3' 이 먼저 수행되고 그 다음에 'x = y'가 수행된다.

```java
x = y = 3

1. y = 3
2. x = y
```

<br>

<br>

### lvalue와 rvalue

대입 연산자의 왼쪽 피연산자를 `lvalue(left value)` 라고 하고, 오른쪽 피연산자를 `rvalue(right value)` 라고 한다.

대입연산자의 rvalue는 변수뿐만 아니라 식이나 상수 등이 모두 가능한 반면, lvalue는 반드시 변수처럼 값을 변경할 수 있는 것이어야 한다. 그래서 리터럴이나 상수같이 값을 저장할 수 없는 것들은 lvalue가 될 수 없다.

```java
int i = 0;          // 에러. lvalue가 값을 저장할 수 있는 공간이 아니다.
3 = i + 3;          // 에러. lvalue의 연산결과는 리터럴(i + 3 --> 0 + 3 --> 3)
i + 3 = i; 

final int MAX = 3;  // 변수 앞에 키워드 fianl을 붙이면 상수가 된다.
MAX = 10;           // 에러. 상수(MAX)에 새로운 값을 저장할 수 없다.
```

변수 앞에 키워드 `final` 을 붙이면 상수가 된다. 상수에 한 번 저장된 값은 바꿀 수 없다.

<br>

<br>

### 복합 대입 연산자

대입 연산자는 다른 연산자(op)와 결합하여 'op='와 같은 방식으로 사용될 수 있다.

<br>

**복합 대입 연산자의 종류**

| op=      | =           |
| -------- | ----------- |
| i += 3;  | i = i + 3;  |
| i -= 3;  | i = i - 3;  |
| i *= 3;  | i = i * 3;  |
| i /= 3;  | i = i / 3;  |
| i %= 3;  | i = i % 3;  |
| i <<= 3; | i = i << 3; |
| i >>= 3; | i = i >> 3; |
| i &= 3;  | i = i & 3;  |
| i ^= 3;  | i = i ^ 3;  |
| i \|= 3; | i = i \| 3; |

