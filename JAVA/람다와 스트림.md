## 1. 람다식(Lambda expression)

람다식이란 메서드를 하나의 식(expression)으로 표현한 것. 함수를 간략하면서도 명확한 식으로 표현할 수 있게 해준다.

메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로, 람다식을 ‘익명함수(anonymous function)’이라고도 한다.

```java
int[] arr = new int[5];
Arrays.setAll(arr, (i) -> (int)(Math.random() * 5) + 1);
```

<br>

<br>

### 1) 작성방법

```java
반환타입 메서드이름(매개변수 선언) {
		문장들
}

(매개변수 선언) -> {
		문장들
}
```

```java
// Before
int amx(int a, int b) {
		return a > b ? a : b;
}

// After
(int a, int b) -> {
		return a > b ? a : b;
}
```

<br>

반환값이 있는 메서드의 경우, return문 대신 식(expression)으로 대체 가능. 연산겨로가가 자동적으로 빈환되기 때문에, 문장(statement)이 아닌 ‘식’이므로 끝에 ‘;’는 생략

```java
(int a, int b) -> { return a > b ? a : b; } --> (int a, int b) -> a > b ? a : b;
```

<br>

매개변수가 하나뿐인 경우에는 괄호()를 생략할 수 있다. But, 매개변수의 타입이 있으면 괄호() 생략X

```java
// Before
(a)     -> a * a
(int a) -> a * a

// After
a     -> a * a // OK
int a -> a * a // ERROR
```

<br>

괄호{}안의 문장이 하나일 때는 괄호{}를 생략할 수 있다.

```java
// Before
(String name, int i) -> {
		System.out.println(name + "=" + i);
}

// After
(String name, int i) ->
		System.out.println(name + "=" + i);

```

<br>

<br>

But, 괄호{} 안의 문장이 return문일 경우 괄호{} 생략X

```java
(int a, int b) -> { return a > b ? a : b; }   // OK.
(int a, int b) ->   return a > b ? a : b;     // ERROR.
```

<br>

<br>

**메서드를 람다식으로 변환**

```java
// Before
int max(int a, int b) {
		return a > b ? a : b;
}

// After
(int a, int b) -> { return a > b ? a : b; }
(int a, int b) -> a > b ? a : b
(a, b) -> a > b ? a : b
```

```java
// Before
vodi printVar(String name, int i) {
		System.out.println(name + "=" + i);
}

// After
(String name, int i) -> { System.out.println(name + "=" + i); }
(name, i) -> { System.out.println(name + "=" + i); }
(name, i) -> System.out.println(name + "=" + i);
```

```java
// Before
int square(int x) {
		return x * x;
}

// After
(int x) -> x * x
(x) -> x * x
x -> x * x
```

```java
// Before
int roll() {
		return (int)(Math.random() * 6);
}

// After
() -> { return (int)(Math.random() * 6); }
() -> (int)(Math.random() * 6)
```

```java
// Before
int sumArr(int[] arr) {
		int sum = 0;
		for (int i : arr)
				sum += i;
		return sum;
}

// After
(int[] arr) -> {
		int sum = 0;
		for (int i : arr)
				sum += i;
		return sum;
}
```

<br>

<br>

### 2) 함수형 인터페이스(Functional Interface)

함수형 인터페이스에는 오직 하나의 추상 메서드만 정의되어 있어야 한다는 제약이 있다. 람다식과 인터페이스의 메서드가 1:1로 연결될 수 있기 때문.

static메서드와 defulat메서드의 개수에는 제약이 없다.

> @FunctionalInterface를 붙이면, 컴파일러가 함수형 인터페이스를 올바르게 정의하였는지 확인해주므로, 꼭 붙이자.



<br>

<br>

```java
// Before
List<String> list = Arrays.asList("abc", "aaa", "bbb", "ddd", "aaa");

Collections.sort(list, new Comparator<String>() {
		public int compare(String s1, String s2) {
				return s2.compareTo(s1);
		}
});

// After
List<String> list = Arrays.asList("abc", "aaa", "bbb", "ddd", "aaa");
Collections.sort(list, (s1, s2) -> s2.compareTo(s1));
```

<br>

<br>

### 함수형 인터페이스 타입의 매개변수와 반환타입

```java
@FunctionalInterface
interface MyFunction {
		void myMethod(); // 추상 메서드
}
```

<br>

메서드의 매개변수가 MyFunction타입이면, 이 메서드를 호출할 때 람다식을 참조하는 참조변수를 매개변수로 지정해야한다는 뜻.

```java
void aMethod(MyFunction f) { // 매개변수의 타입이 함수형 인터페이스
		f.myMethod();            // MyFunciton에 정의된 메서드 호출
}
```

<br>

or 참조변수 없이 직접 람다식으로 매개변수로 지정가능

```java
aMethod(() -> System.out.println("myMethod()")); // 람다식을 매개변수로 지정
```

<br>

메서드의 반환타입이 함수형 인터페이스타입리마녀, 이 함수형 인터페이스의 추상메서드와 동등한 람다식을 가리키는 참조변수를 반환하거나 람다식을 직접 반환할 수 있다.

```java
MyFunction myMethod() {
		MyFunction f = () -> {};
		return f;    // 이 줄과 윗줄을 한 줄로 줄이면, return () -> {};
}
```

<br>

<br>

### 람다식의 타입과 형변환

```java
MyFunciton f = (MyFunction)(() -> {}); // 양변의 타입이 다르므로 형변환이 필요
```

<br>

람다식은 오직 함수형 인터페이스로만 형변환이 가능

```java
Object obj = (Object)(() -> {}); // 에러. 함수형 인터페이스로만 형변환 가능
```

<br>

Object타입으로 형변환하려면, 함수형 인터페이스로 변환해야 한다.

```java
Object obj = (Object)(MyFunction)(() -> {});
String str = ((Object)(MyFunction)(() -> {})).toString();
```

<br>

<br>

### 4) function패키지

매번 함수형 인터페이스르 정의하지 말고, 가능하면 이 패키지의 인터페이스를 활용하는 것이 좋다.

| 함수형 인터페이스 | 메서드 | 설명 |
| --- | --- | --- |
| Runnable | void run() | 매개변수도 없고, 반환값도 없음. |
| Supplier<T> | T get() | 매개변수는 없고, 반환값만 있음. |
| Comsumer<T> | void accept(T t) | Supplier와 반대로 매개변수만 있고, 반환값이 없음. |
| Function<T, R> | R apply(T t) | 일반적인 함수. 하나의 매개변수를 받아서 결과를 반환. |
| Predicate<T> | boolean test(T t) | 조건식을 표현하는데 사용함.<br />매개변수는 하나. 반환 타입은 boolean |

<br>

<br>

### 조건식의 표현에 사용되는 Predicate

Predicate는 Function의 변형, 반환타입이 boolean이라는 것만 다르다.

```java
Predicate<String> isEmptyStr = s -> s.length() == 0;
String s = "";

if (isEmptyStr.test(s)) // if(s.length() == 0)
		System.out.println("This is an empty String.");
```

<br>

<br>

### 매개변수가 두 개인 함수형 인터페이스

매개변수의 개수가 2개인 함수형 인터페이스는 이름앞에 접두사 “Bi”가 붙는다.

| 함수형 인터페이스 | 메서드 | 설명 |
| --- | --- | --- |
| BiConsumer<T, U> | void accept(T t, U u) | 두 개의 매개변수만 있고, 반환값이 없음. |
| BiPredicate<T, U> | boolean test(T t, U u) | 조건식을 표현하는데 사용됨.<br />매개변수는 둘, 반환값은 boolean |
| BiFUnction<T, U, R> | R apply(T t, U u) | 두 개의 매개변수를 받아서 하나의 결과를 반환함. |

<br>

<br>

### UnaryOperator와 BinaryOperator

| 함수형 인터페이스 | 메서드 | 설명 |
| --- | --- | --- |
| UnaryOperation<T> | T apply(T t) | Function의 자손. Function과 달리<br />매개변수와 결과의 타입이 같다. |
| BinaryOperator<T> | T apply(T t, T t) | BiFunction의 자손. BiFunction와<br />달리 매개변수와 결과의 타입이 같다. |

<br>

<br>

### 컬렉션 프레임웍과 함수형 인터페이스

| 인터페이스 | 메서드 | 설명 |
| --- | --- | --- |
| Collection | boolean removeIf(Predicate<E> filter) | 조건에 맞는 요소를 삭제 |
| List | void replaceAll(UnaryOperator<E> operator) | 모든 요소를 변환하여 대체 |
| Iterable | void forEach(Consumer<T> action) | 모든 요소에 작업 action을 수행 |
| Map | V compute(K key, BiFunction<K.V.V> f) | 지정된 키의 값에 작업 f를 수행 |
|  | V computeIfAbsent(K key, Function<K.V> f) | 키가 없으면, 작업 f 수행 후 추가 |
|  | V computeIfPresent(K key, BiFunction<K.V.V> f) | 지정된 키가 있을 떄, 작업 f 수행 |
|  | V merge(K key, V value, BiFunction<V.V.V.> f) | 모든 요소에 병합작업 f를 수행 |
|  | void forEach(BiConsumer<K.V> action) | 모든 요소에 작업 action을 수행 |
|  | void replaceAll(BiFunction<K.V.V> f) | 모든 요소에 치환작업 f를 수행 |

<br>

<br>

### 기본형을 사용하는 함수형 인터페이스

| 함수형 인터페이스 | 메서드 | 설명 |
| --- | --- | --- |
| DoubleToIntFunction | int applyAsInt(double d) | AToBFunction은 입력이 A타입<br />출력이 B타입 |
| ToIntFunction<T> | int applyAsInt(T value) | ToBFunction은 출력이 B타입<br />입력은 지네릭 타입 |
| IntFunction<R> | R apply(T t, U u) | AFunction은 입력이 A타입이고<br />출력은 지네릭 타입 |
| ObjIntConsumer<T> | void accept(T t, U u) | ObjAFunction은 입력이 T, A<br />타입이고 출력은X |

<br>

<br>

<br>

### 5) Function의 합성과 Predicate의 결합

```java
Function
default <V> Function<T,V> andThen(Function<? super R,? extends V> after;
default <V> Function<V,R> compose(Function<? super V,? extends T> before)
static  <V> Function<T,T> ientity()

Predicate
default Predicate<T>    and(Predicate<? super T> other)
default Predicate<T>    or(Predicate<? super T> other)
default Predicate<T>    negate()
static <T> Predicate<T> isEqual(Object targetRef)
```

<br>

### Function의 합성

```java
default <V> FUnction<T,V> andThen(Function<? super R,? extends V> after)
default <V> FUnction<V,R> compose(Function<? super V,? extends T> before)
```

<br>

Ex) 문자열을 숫자로 변환하는 함수 f와 숫자를 2진 문자열로 변환하는 함수 g를 andThen()으로 합성하여 새로운 함수 h를 만들어낼 수 있다.

```java
Function<String, Integer> f = (s) -> Integer.parseInt(s, 16);
Function<Integer, String> g = (i) -> Integer.toBinaryString(i);
Function<String, String> h = f.andThen(g);
```

<br>

함수 h의 지네릭 타입이 <String, String>이다. String을 입력받아서 String을 결과로 반환한다.

Ex) 함수 h에 문자열 “FF”를 입력하면, 결과로 “111111”을 얻는다.

```java
System.out.println(h.apply("FF")); // "FF" -> 255 -> "111111"
```

<br>

compose()를 이용해서 두 함수를 반대의 순서로 합성도 가능하다.

```java
Function<Integer, String>  g = (i) -> Integer.toBinaryString(i);
Function<String, Integer>  f = (s) -> Integer.parseInt(s, 16);
Function<Integer, Integer> h = f.compose(g);
```

```java
System.out.println(h.apply(2)); // 2 -> "10" -> 16
```

<br>

<br>

### Predicate의 결합

and(), or(), negate()로 연결해서 하나의 새로운 Predicate로 결합할 수 있다.

```java
Predicate<Integer> p = i -> i < 100;
Predicate<Integer> q = i -> i < 200;
Predicate<Integer> r = i -> i % 2 == 0;
Predicate<Integer> notP = p.negate();     // i >= 100

// 100 <= i && (i < 200 || i % 2 == 0)
Predicate<Integer> all = notP.and(q.or(r));
System.out.println(all.test(150));        // true
```

<br>

**Lambda**

```java
Predicate<Integer> all = notP.and(i -> i < 200).or(i -> i % 2 == 0);
```

<br>

<br>

```java
Predicate<String> p = Predicate.isEqual(str1);
boolean result = p.test(str2);    // str1과 str2가 같은지 비교하여 결과를 반환
```

<br>

**Lambda**

```java
// str1과 str2가 같은지 비교
boolean result = Predicate.isEqual(str1).test(str2);
```

<br>

<br>

### 6) 메서드 참조

람다식이 하나의 메서드만 호출하는 경우에는 ‘메서드 참조(method reference)’라는 방법으로 람다식을 간략히 할 수 있다.

Ex) 문자열을 정수로 변환하는 람다식

```java
Function<String, Integer> f = (String s) -> Integer.parseInt(s);
```

```java
// Before
Function<String, Integer> f = (String s) -> Integer.parseInt(s);
BiFunction<String, String, Boolean> f = (s1, s2) -> s1.equals(s2);

// After
Function<String, Integer> f = Integer::parseInt;        // 메서드 참조
BiFunction<String, String, Boolean> f = String::equals; // 메서드 참조
```

<br>

이미 생성된 객체의 메서드를 람다식에서 사용한 경우: 클래스 이름 대신 그 객체의 참조변수를 적워줘야 한다.

```java
MyClass obj = new MyClass();
Function<String, Boolean> f = (x) -> obj.equals(x); // 람다식
Function<String, Boolean> f2 = obj::equals;         // 메서드 참조
```

<br>

| 종류 | 람다 | 메서드 참조 |
| --- | --- | --- |
| static 메서드 참조 | (x) → ClassName.method(x) | ClassName::method |
| 인스턴스메서드 참조 | (obj, x) → obj.method(x) | ClassName::method |
| 특정 객체 인스턴스메서드 참조 | (x) → obj.method(x) | obj::method |

<br>

<aside>
💡 하나의 메서드만 호출하는 람다식은 ‘클래스이름::메서드이름’ 또는 ‘참조변수::메서드이름’으로 바꿀 수 있다.
</aside>

<br>

<br>

### 생성자의 메서드 참조

```java
Supplier<MyClass> s = () -> new MyClass(); // 람다식
Supplier<MyClass> s = MyClass::new;        // 메서드 참조
```

<br>

매개변수가 있는 생성자라면, 매개변수의 개수에 따라 알맞은 함수형 인터페이스를 사용하면 된다.

필요하다면 함수형 인터페이스를 새로 정의해야 한다.

```java
Function<Integer, MyClass> f  = (i) -> new MyClass(i);   // 람다식
Function<Integer, MyClass> f2 = MyClass::new;            // 메서드 참조

BiFunction<Integer, String, MyClass> bf = (i, s) -> new MyClass(i, s);
BiFunction<Integer, String, MyClass> bf2 = MyClass::new; // 메서드 참조
```

<br>

배열을 생성할 때

```java
Function<Integer, int[]> f  = x -> new int[x]; // 람다식
Function<Integer, int[]> f2 = int[]::new;      // 메서드 참조
```

메서드 참조는 람다식을 마치 static변수처럼 다룰 수 있게 해준다.