## 1. 컬렉션 프레임워크(Collections Framework)

---

- 컬렉션 프레임워크란?
  
    ⇒ 데이터 군을 저장하는 표준화한설계
    
    ⇒ 컬렉션(Collection)은 다수의 데이터, 즉 데이터 그룹을,
    ⇒ 프레임워크는 표준화된 프로그래밍 방식을 의미

<br>

<br>

JDK1.2 이전까지는 Vector, Hashtable, Properties와 같은 컬렉션 클래스, 다수의 데이터를 저장할 수 있는 클래스 들을 서로 다른 각자의 방식으로 처리해야 했음.

JDK1.2부터 컬렉션 프레임워크가 등장하면서 다양한 종류의 컬렉션 클래스가 추가되고 모든 컬렉션 클래스를 표준화된 방식으로 다룰 수 있도록 체계화됨

<br>

**장점**

- 인터페이스와 다형성을 이용한 객체지향적 설계를 통해 표준화되어 있기 때문에 사용법을 익히기에도 편리하고 재사용성이 높은 코드를 작성할 수 있다.

<br>

<br>

### 1) 컬렉션 프레임워크의 핵심 인터페이스

컬렉션데이터 그룹을 크게 3가지 타입이 존재한다고 인식하고 각 컬렉션을 다루는데 필요한 기능을 3개의 인터페이스를 정의하였다. 그리고 인터페이스 List와 Set의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 Collection을 추가로 정의하였다.

![picture](https://github.com/JaeYeon33/TIL/blob/main/JAVA/image/Untitled%2013.png?raw=true)



<br>

<br>

**컬렉션 프레임워크의 핵심 인터페이스와 특징**

| 인터페이스 | 특징                                                         |
| ---------- | ------------------------------------------------------------ |
| List       | 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다. <br />예) 대기자 명단 |
|            | 구현 클래스 : ArrayList, LinkedList, Stack, Vector등         |
| Set        | 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.<br />예) 양의 정수집합, 소수의 집합 |
|            | 구현 클래스 : HashSet, TreeSet 등                            |
| Map        | 키(key)와 값(value)의 쌍(pari)으로 이루어진 데이터의 집합 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다. <br />예) 우편번호, 지역번호(전화번호) |
|            | 구현 클래스 : HashMap, TreeMap, Hashtable, Properties 등     |



<br>

> 키(Key) : 데이터 집합 중에서 어떤 값(value)을 찾는데 열쇠(Key)가 된다는 의미에서 붙여진 이름이다. 그래서 키(Key)는 중복을 허용하지 않는다.

<br>

컬렉션 프레임워크의 모든 컬렉션 클래스들은 List, Set, Map 중의 하나를 구현하고 있으며, 구현한 인터페이스의 이름이 클래스의 이름에 포함되어있어서 이름만으로도 클래스의 특징을 쉽게 알 수 있도록 되어있다.

그러나 Vector, Stack, Hashtable, Properteis와 같은 클래스들은 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 것이기 때문에 컬렉션 프레임워크의 명명법을 따르지 않는다.

<u>Vector 나 Hashtable과 같은 기존의 컬렉션 클래스들은 호환을 위해, 설계를 변경해서 남겨두었지만 가능하면 사용하지 않는 것이 좋다. 대신 새로 추가된 ArrayList와 HashMap을 사용하자.</u>

<br>

![picture](https://github.com/JaeYeon33/TIL/blob/main/JAVA/image/Untitled%2014.png?raw=true)

<br>

<br>

### Collection 인터페이스

**Collection인터페이스에 정의된 메서드**

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| boolean add(Object o) <br />boolean addAll(Collection c)     | 지정된 객체(o) 또는 Collection(c) 의 객체들을 Collection에 추가한다. |
| void clear()                                                 | Collection의 모든 객체를 삭제한다.                           |
| boolean contains(Obejct o) <br />boolean containsAll(Collection c) | 지정된 객체(o) 또는 Collection의 객체들이 Collection에 포함되어 있는지 확인한다. |
| boolean equals(Obejct o)                                     | 동일한 Collection인지 확인한다.                              |
| int hashCode()                                               | Collection의 hash code를 반환한다.                           |
| boolean isEmpty()                                            | Collection이 비어있는지 확인한다.                            |
| iterator iterator()                                          | Collection의 iterator를 얻어서 반환한다.                     |
| boolean remove(Object o)                                     | 지정된 객체를 삭제한다.                                      |
| boolean retainAll(Collection c)                              | 지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 Collection에서 삭제한다. <br />이 작업으로 인해 Collection에 변화가 있으면 true, 아니면 false를 반환한다. |
| int size()                                                   | Collection에 저장된 객체의 개수를 반환한다.                  |
| Object[] toArray()                                           | Collection에 저장된 객체를 객체배열(Obejct[])로 반환한다.    |
| Obejct[] toArray(Obejct[] a)                                 | 지정된 배열에 Collection의 객체를 저장해서 반환한다.         |



<br>

<br>

### List인터페이스

⇒ **중복을 허용**하면서 **저장순서가 유지**되는 컬렉션을 구현하는데 사용된다.

![picture](https://github.com/JaeYeon33/TIL/blob/main/JAVA/image/Untitled%2015.png?raw=true)

<br>

<br>

**List인터페이스의 메서드**

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| void add(int index, Object element) <br />boolean addAll(int index, Collection c) | 지정된 위치(index)에 객체(element) 또는 컬렉션에 포함된 객체들을 추가한다. |
| Object get(int index)                                        | 지정된 위치(index)에 있는 객체를 반환한다.                   |
| int indexOf(Object o)                                        | 지정된 객체의 위치(index)를 반환한다. <br />(List의 첫 번째 요소부터 순방향으로 찾는다.) |
| ListIterator listIterator() <br />ListIterator listIterator(int index) | List의 객체에 접근할 수 있는 ListIterator를 반환한다.        |
| Object remove(int index)                                     | 지정된 위치(index)에 있는 객체를 삭제하고 삭제된 객체를 반환한다. |
| Object set(int index, Object element)                        | 지정된 위치(index)에 객체(element)를 저장한다.               |
| void sort(Comparator c)                                      | 지정된 비교자(comparator)로 List를 정렬한다.                 |
| List subList(int fromIndex, int toIndex)                     | 지정된 범위(fromIndex부터 toIndex)에 있는 객체를 반환한다.   |



<br>

<br>

### Set인터페이스

⇒ 중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 구현하는데 사용.

- Set인터페이스를 구현한 클래스 : HashSet, TreeSet 등이 있다.

![picture](https://github.com/JaeYeon33/TIL/blob/main/JAVA/image/Untitled%2016.png?raw=true)

<br>

<br>

### Map인터페이스

⇒ 키(key)와 값(value)을하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는 데 사용된다.

키는 중복될 수 없지만 값을 중복을 허용. 기존에 저장된 데이터와 중복된 키와 값을 저장하면 기존의 값은 없어지고 마지막에 저장된 값이 남게된다.

- Map인터페이스를 구현한 클래스 : Hashtable, HashMap, LinkedHashMap, SortedMap, TreeMap 등이 있다.

<br>

![picture](https://github.com/JaeYeon33/TIL/blob/main/JAVA/image/Untitled%2017.png?raw=true)

<br>

<br>

**Map인터페이스의 메서드**

| 메서드                               | 설명                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| void clear()                         | Map의 모든 객체를 삭제한다.                                  |
| boolean containsKey(Object key)      | 지정된 key객체와 일치하는 Map의 key객체가 있는지 확인한다.   |
| boolean containsValue(Object value)  | 지정된 value객체와 일치하는 Map의 value객체가 있는지 확인한다. |
| Set entrySet()                       | Map에 저장되어 있는 key-value쌍을 Map.Entry타입의 객체로 저장한 Set으로 반환한다. |
| boolean equals(Object o)             | 동일한 Map인지 비교한다.                                     |
| Object get(Object key)               | 지정한 key객체에 대응하는 value객체를 찾아서 반환한다.       |
| int hashCode()                       | 해시코드를 반환한다.                                         |
| boolean isEmpty()                    | Map이 비어있는지 확인한다.                                   |
| Set keySet()                         | Map에 저장된 모든 key객체를 반환한다.                        |
| Object put(Object key, Object value) | Map에 value객체를 key객체에 연결(mapping)하여 저장한다.      |
| void putAll(Map t)                   | 지정된 Map의 모든 key-value쌍을 추가한다.                    |
| Object remove(Object key)            | 지정한 key객체와 일치하는 key-value객체를 삭제한다.          |
| int size()                           | Map에 저장된 key-value쌍의 개수를 반환한다.                  |
| Collection values()                  | Map에 저장된 모든 value객체를 반환한다.                      |



<br>

<br>

- value() → 반환타입 Colleciton
- keySet() → 반환타입 Set

Map인터페이스에서 값(value)은 중복을 허용하기 때문에 Collection타입으로 반환하고, 키(key)는 중복을 허용하지 않기 때문에 Set타입으로 반환한다.

<br>

<br>

### Map.Entry인터페이스

⇒ Map인터페이스의 내부 인터페이스이다. 내부 클래스와 같이 인터페이스도 인터페이스 안에 인터페이스를 정의하는 내부 인터페이스(inner interface)를 정의하는 것이 가능하다.

Map에 저장되는 key-value쌍을 다루기 위해 내부적으로 Entry인터페이스를 정의해놓았다. 이것은 보다 객체지향적으로 설계하도록 유도하기 위한 것으로 Map인터페이스를 구현하는 클래스에서는 Map.Entry인터페이스도 함꼐 구현해야한다.

```java
public interface Map {
		...
		public static interface Entry {
				Object getKey();
				Object getValue();
				Object setValue(Object value);
				boolean equals(Object o);
				int hasCode();
				...  // JDK8.0부터 추가된 메서드는 생략
		}
}
```

<br>

<br>

**Map.Entry인터페이스의 메서드**

| 메서드                        | 설명                                      |
| ----------------------------- | ----------------------------------------- |
| boolean equals(Object o)      | 동일한 Entry인지 비교한다.                |
| Obejct getKey()               | Entry의 key객체를 반환한다.               |
| Objet getValue()              | Entry의 value객체를 반환한다.             |
| int hasCode()                 | Entry의 해시코드를 반환한다.              |
| Object setValue(Object value) | Entry의 value객체를 지정된 객체로 바꾼다. |



<br>

<br>



### 2) ArrayList

⇒ 컬렉션 프레임워크에서 가장 많이 사용되는 컬렉션 클래스일 것이다.

List인터페이스를 구현하기 때문에 데이터의 저장순거가 유지되고 중복을 허용한다는 특징을 갖는다.

ArrayList는 기존의 Vector를 개선한 것으로 Vector와 구현원리와 기능적인 측면에서 동일하다고 할 수 있다. Vector는 기존에 작성된 소스와의 호환성을 위해서 계속 남겨두고 있을 뿐 가능하면 ArrayList를 사용하자.

ArrayList는 Object배열을 이용해서 데이터를 순차적으로 저장한다.

Ex) 첫 번째로 저장한 객체는 Object배열의 0번째 위치에 저장되고, 그 다음에 저장하는 객체는 1번째 위치에 저장된다. 이런식으로 배열에 순서대로 저장되며, 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장된다.

<br>

```java
public class ArrayList extends AbstractList
		implements List, RandomAccess, Cloneable, java.io.Serializable {
						...
				transient Object[] elementData;  // Object 배열
						...
}
```

ArrayList는 elementData라는 이름의 Object배열을 멤버변수로 선언하고 있다는 것을 알 수 있다. 선언된 배열의 타입이 모든 객체의 최고조상인 Object이기 떄문에 모든 종류의 객체를 담을 수 있다.

<br>

<br>

**ArrayList의 생성자와 메서드**

| 메서드                                   | 설명                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| ArrayList()                              | 크기가 10인 ArrayList를 생성                                 |
| ArrayList(Collection c)                  | 주어진 컬렉션이 저장된 ArrayList를 생성                      |
| ArrayList(int initialCapacity)           | 지정된 초기용량을 갖는 ArrayList를 생성                      |
| boolean add(Object o)                    | ArrayList의 마지막에 객체를 추가. 성공하면 true              |
| void add(int index, Object element)      | 지정된 위치(index)에 객체를 저장                             |
| boolean addAll(Collection c)             | 주어진 컬렉션의 모든 객체를 저장한다.                        |
| boolean addAll(int index, Collection c)  | 지정된 위치부터 주어진 컬렉션의 모든 객체를 저장한다.        |
| void clear()                             | ArrayList를 완전히 비운다.                                   |
| Object clone()                           | ArrayList를 복제한다.                                        |
| boolean contains(Object o)               | 지정된 객체(o)가 ArrayList에 포함되어 있는 지 확인           |
| void ensureCapacity(int minCapacity)     | ArrayList의 용량이 최소한 minCapacity가 되도록 한다.         |
| Obejct get(int index)                    | 지정된 위치(index)에 저장된 객체를 반환한다.                 |
| int indexOf(Obejct o)                    | 지정된 객체가 저장된 위치를 찾아 반환한다.                   |
| boolean isEmpty()                        | ArrayList가 비어있는지 확인한다.                             |
| Iterator iterator()                      | ArrayList의 Iterator객체를 반환                              |
| int lastIndexOf(Obejct o)                | 객체(o)가 저장된 위치를 끝부터 역방향으로 검색해서 반환      |
| ListIterator listIterator()              | ArrayList의 ListIterator를 반환                              |
| ListIterator listIterator(int index)     | ArrayList의 지정된 위치부터 시작하는 ListIterator를 반환     |
| Object remove(int index)                 | 지정된 위치(index)에 있는 객체를 제거한다.                   |
| boolean remove(Object o)                 | 지정된 객체를 제거한다.(성공하면 true. 실패하면 false)       |
| boolean removeAll(Collection c)          | 지정한 컬렉션에 저장된 것과 동일한 객체들을 ArrayList에서 제거한다. |
| boolean retainAll(Collection c)          | ArrayList에 저장된 객체 중에서 주어진 컬렉션과 공통된 것들만을 남기고 나머지는 삭제한다. |
| Object set(int index, Object element)    | 주어진 객체(element)를 지정된 위치(index)에 저장한다.        |
| int size()                               | ArrayList에 저장된 객체의 개수를 반환한다.                   |
| void sort(Comparator c)                  | 지정된 정렬기준(c)으로 ArrayList를 정렬                      |
| List subList(int fromIndex, int toIndex) | fromIndex부터 toIndex사이에 저장된 객체를 반환한다.          |
| Object[] toArray()                       | ArrayList에 저장된 모든 객체들을 객체배열로 반환한다.        |
| Obejct[] toArray(Object[] a)             | ArrayList에 저장된 모든 객체들을 객체배열 a에 담아 반환한다. |
| void trimToSize()                        | 용량을 크기에 맞게 줄인다.(빈 공간을 없앤다.)                |



<br>

<br>

### 3) LinkedList

⇒ 배열은 가장 기본적인 형태의 자료구조로 구조가 단단하며 사용하기 쉽고 데이터를 읽어오는데 걸리는 시간(접근시간, access time)이 가장 빠르다는 장점을 가지고 있지만 단점도 있다.

1. 크기를 변경할 수 없다.

   - 크기를 변경할 수 없으므로 새로운 배열을 생성해서 데이터를 복사해야한다.

   - 실행속도를 향상시키기 위해서는 충분히 큰 크기의 배열을 생성해야 하므로 메모리가 낭비된다.

2. 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.

   - 차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르지만,

   - 배열의 중간에 데이터를 추가하려면, 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야 한다.


<br>

<br>

이러한 배열의 단점을 보완하기 위해서 링크드 리스트(linked list)라는 자료구조가 고안되었다.

- 배열 : 모든 데이터가 연속적으로 존재
- LinkedList : 불연속적으로 존재하는 데이터를 서로 연걸(link)한 형태로 구성

![picture](https://github.com/JaeYeon33/TIL/blob/main/JAVA/image/Untitled%2018.png?raw=true)

<br>

<br>

위의 그림에서 알 수 있듯이 링크드 리스트의 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 구성

```java
class Node {
		Node next;   // 다음 요소의 주소를 저장
		Object obj;  // 데이터를 저장
}
```

<br>

링크드 리스트에서의 데이터 삭제는 간단하다. 삭제하고자 하는 요소의 이전요소가 삭제하고자 하는 요소의 다음 요소를 참조하도록 변경하기만 하면 된다. 단 하나의 참조만 변경하면 삭제가 이루어지는 것이다. 배열처럼 데이터를 이동하기 위해 복사하는 과정이 없기 때문에 매우 빠르다.

<br>

새로운 데이터를 추가할 때는 새로운 요소를 생성한 다음 추가하고자 하는 위치의 이전 요소의 참조를 새로운 요소에 대한 참조로 변경해주고, 새로운 요소가 그 다음 요소를 참조하도록 변경하기만 하면 처리속도가 매우 빠르다.

<br>

링크드 리스트는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전요소에 대한 접근은 어렵다. 이 점을 보완한 것 : 더블 링크드 리스트(이중 연결 리스트, doubly linked list)

- 단순히 링크드 리스트에 참조변수를 하나 더 추가하여 다음 요소에 대한 참조뿐 아니라 이전 요소에 대한 참조가 가능하도록 했을 뿐, 그 외에는 링크드 리스트와 같다.
- 링크드 리스트보다 각 요소에 대한 접근과 이동이 쉽기 때문에 링크드 리스트보다 더 많이 사용된다.

```java
class Node {
		Node next;      // 다음 요소의 주소를 저장
		Node previous;  // 이전 요소의 주소를 저장
		Object obj;     // 데이터를 저장
}
```

<br>

![picture](https://github.com/JaeYeon33/TIL/blob/main/JAVA/image/Untitled%2019.png?raw=true)



<br>

- 더블 써큘러 링크드 리스트(이중 원형 연결리스트, doubly circular linked list) : 더블 링크드 리스트의 접근성을 보다 향상시킨 것
    - 단순히 첫 번째 요소와 마지막 요소를 서로 연결시킨 것
    - 이렇게 하면, 마지막요소의 다음요소가 첫 번째 요소가 되고, 첫 번째 요소의 이전 요소가 마지막 요소가 된다.
    Ex) TV의 마지막 채널에서 채널을 증가시키면 첫 번째 채널로 이동하고 첫 번째 채널에서 채널을 감소시키면 마지막 채널로 이동하는 것과 같다.

![picture](https://github.com/JaeYeon33/TIL/blob/main/JAVA/image/Untitled%2020.png?raw=true)



<br>

<aside>
⚠️ 실제로 LinkedList클래스는 이름과 달리 '링크드 리스트'가 아닌 '더블 링크드 리스트'로 구현되어 있는데, 이는 링크드 리스트의 단점인 낮은 접근성(accessability)을 높이기 위한 것
</aside>

<br>

<br>

**LinkedList의 생성자와 메서드**

| 생성자 또는 메서드                       | 설명                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| LinkedList()                             | LinkedList 객체를 포함                                       |
| LinkedList(Collection c)                 | 주어진 컬렉션을 포함하는 LinkedList 객체를 생성              |
| boolean add(Object o)                    | 지정된 객체(o)를 LinkedList의 끝에 추가. 저장에 성공하면 true. 실패하면 false |
| void add(int index, Object element)      | 지정된 위치(index)에 객체(element)를 추가                    |
| boolean addAll(Collection c)             | 주어진 컬렉션에 포함된 모든 요소를 LinkedList의 끝에 추가한다. 성공하면 true. 실패하면 false |
| boolean addAll(int index, Collection c)  | 지정된 위치(index)에 주어진 컬렉션에 포함된 모든 요소를 추가. 성공하면 true. 실패하면 false |
| void clear()                             | LinkedList의 모든 요소를 삭제                                |
| boolean contains(Object o)               | 지정된 객체가 LinkedList에 포함되었는지 알려줌               |
| boolean containsAll(Colleciton c)        | 지정된 컬렉션의 모든 요소가 포함되었는지 알려줌              |
| Object get(int index)                    | 지정된 위치(index)의 객체를 반환                             |
| int indexOf(Object o)                    | 지정된 객체가 저장된 위치(앞에서 몇 번째)를 반환             |
| boolean isEmpty()                        | LinkedList가 비어있는지 알려준다. 비어있으면 true            |
| iterator iterator()                      | Iterator를 반환한다.                                         |
| int lastIndexOf(Object o)                | 지정된 객체의 위치(index)를 반환(끝부터 역순검색)            |
| ListIterator listIterator()              | ListIterator를 반환한다.                                     |
| ListIterator listIterator(int index)     | 지정된 위치에서부터 시작하는 ListIterator를 반환             |
| Object remove(int index)                 | 지정된 위치(index)의 객체를 LinkedList에서 제거              |
| boolean remove(Object o)                 | 지정된 객체를 LinkedList에서 제거. 성공하면 true. 실패하면 false. |
| boolean removeAll(Collection c)          | 지정된 컬렉션의 요소와 일치하는 요소를 모두 삭제             |
| boolean retainAll(Collection c)          | 지정된 컬렉션의 모든 요소가 포함되어 있는지 확인             |
| Object set(int index, Object element)    | 지정된 위치(index)의 객체를 주어진 객체로 바꿈               |
| int size()                               | LinkedLis에 저장된 객체의 수를 반환                          |
| List subList(int fromIndex, int toIndex) | LinkedList의 일부를 List로 반환                              |
| Object[] toArray()                       | LinkedList에 저장된 객체를 배열로 반환                       |
| Object[] toArray(Object[] a)             | LinkedList에 저장된 객체를 주어진 배열에 저장하여 반환       |
| Object[] element()                       | LinkedList의 첫 번째 요소를 반환                             |
| boolean offer(Obejct o)                  | 지정된 객체(o)를 LinkedList의 끝에 추가. 성공하면 true. 실패하면 false |
| Object peek()                            | LinkedList의 첫 번째 요소를 반환                             |
| Object poll()                            | LinkedList의 첫번째 요소를 반환. LinkedList에서는 제거된다.  |
| Object remove()                          | LinkedList의 첫 번째 요소를 제거                             |
| void addFirst(Object o)                  | LinkedList의 맨 앞에 객체(o)를 추가                          |
| void addLast(Object o)                   | LinkedList의 맨 끝에 객체(o)를 추가                          |
| Iterator descendingIterator()            | 역순으로 조회하기 위한 DescendingIterator을 반환             |
| Object getFirst()                        | LinkedList의 첫번째 요소를 반환                              |
| Object getLast()                         | LinkedList의 마지막 요소를 반환                              |
| boolean offerFirst(Object o)             | LinkedList의 맨 앞에 객체(o)를 추가. 성공하면, true          |
| boolean offerLast(Object o)              | LinkedList의 맨 끝에 객체(o)를 추가. 성공하면, true          |
| Object peekFirst()                       | LinkedList의 첫번째 요소를 반환                              |
| Object peekLast()                        | LinkedList의 마지막 요소를 반환                              |
| Object pollFirst()                       | LinkedList의 첫번째 요소를 반환하면서 제거                   |
| Object poolLast()                        | LinkedList의 마지막 요소를 반환하면서 제거                   |
| Object pop()                             | removeFirst()와 동일                                         |
| void push(Object o)                      | addFirst()와 동일                                            |
| Object removeFirst()                     | LinkedList의 첫번째 요소를 제거                              |
| Object removeLast()                      | LinkedList의 마지막 요소를 제거                              |
| boolean removeFirstOccurrence(Object o)  | LinkedList에서 첫번째로 일치하는 객체를 제거                 |
| boolean removeLAstOccurrence(Object o)   | LinkedList에서 마지막으로 일치하는 객체를 제거               |



<br>

LinkedList역시 List인터페이스를 구현했기 때문에 ArrayList와 내부구현방법만 다를뿐 제공하는 메서드의 종류와 기능은 거의 같다.

<br>

<br>

### 4) Stack과 Queue

- Stack : 마지막에 저장한 데이터를 가장 먼저 꺼내게 되는 LIFO(Last In First Out)구조
    - 동전통과 같은 구조로 양 옆과 바닥이 막혀 있어서 한 방향으로만 뺼 수 있는 구조
- Queue : 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 FIFO(First In First Out) 구조
    - 양 옆만 막혀 있고 위아래로 뚫려 있어서 한 방향으로는 넣고 한 방향으로는 빼는 파이프와 같은 구조

![picture](https://github.com/JaeYeon33/TIL/blob/main/JAVA/image/Untitled%2021.png?raw=true)

<br>

<br>

어떤 컬렉션 클래스를 사용하는 것이 좋을까?

- Stack : ArrayList와 같은 배열기반의 컬렉션 클래스
- Queue : 데이터를 꺼낼 때 항상 첫 번째 저장된 데이터를 삭제하므로, ArrayList와 같은 배열기반의 컬렉션 클래스를 사용한다면 데이터를 꺼낼 때마다 빈 공간을 채우기 위해 데이터의 복사가 발생하므로 비효율적이다. 데이터의 추가/삭제가 쉬운 LinkedList로 구현하는 것이 더 적합.

<br>

**Stack의 메서드**

| 메서드                   | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| boolea empty()           | Stack이 비어있는지 알려준다.                                 |
| Object peek()            | Stack의 맨 위에 저장된 객체를 반환. pop()과 달리 Stack에서 객체를 꺼내지는 않음. <br />(비었을 때는 EmptyStackException발생) |
| Object pop()             | Stack의 맨 위에 저장된 객체를 꺼낸다. (비었을 때는 EmptyStackException 발생) |
| Object push(Object item) | Stack에 객체(item)를 저장한다.                               |
| int search(Object o)     | Stack에서 주어진 객체(o)를 찾아서 그 위치를 반환. 못찾으면 -1을 반환. <br />(배열과 달리 위치는 0이 아닌 1부터 시작) |



<br>

<br>

**Queue의 메서드**

| 메서드                  | 설명                                                         |
| ----------------------- | ------------------------------------------------------------ |
| boolean add(Object o)   | 지정된 객체를 Queue에 추가한다. 성공하면 true를 반환. <br />저장공간이 부족하면 IllegalStateException 발생 |
| Object remove()         | Queue에서 객체를 꺼내 반환. 비어있으면 NoSuchElementException 발생 |
| Object element()        | 삭제없이 요소를 읽어온다. peek와 달리 Queue가 비었을 때 <br />NoSuchElemetnException 발생 |
| boolean offer(Object o) | Queue에 객체를 저장. 성공하면 true, 실패하면 false를 반환    |
| Object poll()           | Queue에 객체를 꺼내서 반환. 비어있으면 null을 반환           |
| Object peek()           | 삭제없이 요소를 읽어 온다. Queue가 비어있으며 null을 반환    |



<br>

<br>

**스택과 큐의 활용**

- 스택의 활용 예 - 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저의 뒤로/앞으로
- 큐의 활용 예 - 최근사용문서, 인쇄작업, 대기목록, 버퍼(buffer)

<br>

<br>

**PriorityQueue**

Queue 인터페이스의 구현체 중의 하나로, 저장한 순서에 관계없이 우선순위(priority)가 높은 것부터 꺼내게 된다는 특징이 있다. 그리고 null은 저장할 수 없다. null을 저장하면 NullPointerException이 발생한다.

PriorityQueue는 저장공간으로 배열을 사용하며, 각 요소를 '힙(heap)'이라는 자료구조의 형태로 저장한다.

> 자료구조 힙(heap)은 앞서 배운 JVM의 힙(heap)과 이름만 같을 뿐 다른 것이다.
> 

<br>

<br>

**Deque(Double-Ended Queue)**

Queue의 변형으로, 한 쪽 끝으로만 추가/삭제할 수 있는 Queue와 달리, Deque(덱, 또는 디큐라고 읽음)은 양쪽 끝에 추가/삭제가 가능하다. Deque의 조상은 Queue이며, 구현체로는 ArrayDeque과 LinkedList 등이 있다.

<br>

<br>

**덱(Deque)의 메서드에 대응하는 큐와 스택의 메서드**

| Deque | Queue | Stack |
| --- | --- | --- |
| offerLast() | offer() | push() |
| pollLast() | - | pop() |
| pollFirst() | poll() | - |
| peekFirst() | peek() |  |
| peekLast() | - | peek() |

<br>

<br>

### 5) Iterator, ListIterator, Enumeration

모두 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스이다.

- Enumeration: Iterator의 구버전
- ListIterator: Iterator의 기능을 향상시킨다.

<br>

**Iterator**

컬렉션에 저장된 각 요소에 접근하는 기능을 가진 Iterator 인터페이스를 정의하고, Coolection 인터페이스에는 'Iterator(Iterator를 구현한 클래스의 인스턴스)'를 반환하는 iterator()를 정의하고 있다.

```java
public interface Iterator {
		boolean hasNext();
		Object next();
		void remove();
}

public interface Collection {
		...
		public Iterator iterator();
}
```

<br>

iterator()는 Collection인터페이스에 정의된 메서드이므로 Collection인터페이스의 자손인 List와 Set에도 포함되어 있다. 그래서 List나 Set인터페이스를 구현하는 컬렉션은 iterator()가 각 컬렉션의 특징에 알맞게 작성되어 있다. 컬렉션 클래스에 대해 iterator()를 호출하여 Iterator를 얻은 다음 반복문, 주로 while문을 상요해서 컬렉션 클래스의 요소들을 읽어올 수 있다.

<br>

<br>

**Iterator 인터페이스의 메서드**

| 메서드 | 설명 |
| --- | --- |
| boolean hasNext() | 읽어 올 요소가 남았는지를 확인한다. 있으면 true, 없으면 false를 반환한다. |
| Object next() | 다음 요소를 읽어 온다. next()를 호출하기 전에 hasNext()를 호출해서 읽어올 요소가 있는지 확인하는 것이 안전하다. |
| void remove() | next()로 읽어 온 요소를 삭제한다. next()를 호출한 다음에 remove()를 호출해야 한다.(선택적기능) |

```java
Collection c = new ArrayList<>(); // 다른 컬렉션으로 변경 시 이 부분만 고치면 된다.
Iterator it = c.iterator();

while(it.hasNext()) {
		System.out.println(it.next());
}
```

<br>

**Q. 참조변수의 타입을 ArrayList타입이 아니라 Collection타입으로 한 이유는?**

A. Collection에 없고 ArrayList에만 있는 메서드를 사용하는게 아니라면, Collection 타입의 참조변수로 선언하는 것이 좋다. 만일 Collection인터페이스를 구현한 다른 클래스, 예를 들어 LinkedList로 바꿔야 한다면 선언문 하나만 변경하면 나머지 코드는 검토하지 않아도 된다. 참조변수 타입이 Colletion이므로 Collection에 정의되지 않은 메서드는 사용되지 않았을 것이 확실하다.

But, 참조변수 타입을 ArrayList로 했다면, 선언문 이후의 문장들을 검토해야 한다. Collection에 정의되지 않은 메서드를 호출했을 수 있기 때문이다.

<br>

<br>

Map 인터페이스를 구현한 컬렉션 클래스는 키(key)와 값(value)을 쌍(pair)으로 저장하고 있기 때문에 iterator()를 직접 호출할 수 없고, 그 대신 keySet()이나 entrySet()과 같은 메서드를 통해서 키와 값을 각각 따로 Set의 형태로 얻어 온 후에 다시 iterator()를 호출해야 Iterator를 얻을 수 있다.

```java
Map map = new HashMap<>();
				...
Iterator it = map.entrySet().iterator();

// Set eSet = map.entrySet();
// Iterator it = eSet.iterator();
1. map.entrySet()의 실행결과가 Set이므로
Iterator it = map.entrySet().iterator(); -> Iterator it = Set인스턴스.iterator();

2. map.entrySet()를 통해 얻은 Set인스턴스의 iterator()를 호출해서 Iterator인스턴스를 얻는다.
Iterator it = Set인스턴스.iterator(); -> Iterator it = Iterator인스턴스;

3. 마지막으로 Iterator인스턴스의 참조가 it에 저장된다.
```

```java
StringBuffer sb = new StringBuffer();
sb.append("A").append("B").append("C"); // StringBuffer append(String str);
```

<br>

<br>

### ListIterator와 Enumeration

Enumeration은 컬렉션 프레임워크가 만들어지기 이전에 사용하던 것으로 Iterator의 구버전이라고 생각하면 된다.

- Enumeration: Iterator의 구버전
- ListIterator: Iterator에 양방향 조회기능추가(List를 구현한 경우만 사용가능)

<br>

<br>

**Enumeration인터페이스의 메서드**

| 메서드 | 설명 |
| --- | --- |
| boolean hasMoreElements() | 읽어 올 요소가 남아있는지 확인한다. 있으면 true, 없으면 false를 반환한다. Iterator의 hasNext()와 같다. |
| Object nextElement() | 다음 요소를 읽어 온다. nextElement()를 호출하기 전에 hasMoreElements()를 호출해서 읽어올 요소가 남았는지 확인하는 것이 안전하다.<br />Iterator의 next()와 같다. |

<br>

<br>

**ListIterator의 메서드**

| 메서드 | 설명 |
| --- | --- |
| void add(Object o) | 컬렉션에 새로운 객체(o)를 추가한다. (선택적 기능) |
| boolean hasNext() | 읽어 올 다음 요소가 남아있는지 확인한다. 있으면 true, 없으면 false를 반환 |
| boolean hasPrevious() | 읽어 올 이전 요소가 남아있는지 확인한다. 있으면 true, 없으면 false를 반환 |
| Object next() | 다음 요소를 읽어 온다. next()를 호출하기 전에 hasNext()를 호출해서 읽어 올 요소가 있는지 확인하는 것이 안전하다. |
| Object previous() | 이전 요소를 읽어 온다. previous()를 호출하기 전에 hasPrevious()를 호출해서 읽어올 요소가 있는지 확인하는 것이 안전하다. |
| int nextIndex() | 다음 요소의 index를 반환한다. |
| int previousIndex() | 이전 요소의 index를 반환한다. |
| void remove() | next() 또는 previous()로 읽어 온 요소를 삭제한다. 반드시 next()나 previous()를 먼저 호출한 다음에 이 메서드를 호출해야한다.(선택적 기능) |
| void set(Object o) | next() 또는 previous()로 읽어 온 요소를 지정된 객체(o)로 변경한다. 반드시 next()나 previous()를 먼저 호출한 다음에 이 메서드를 호출해야 한다. (선택적 기능) |

- Iterator: 단방향으로만 이동하기 떄문에 컬렉션의 마지막 요소에 다다르면 더 이상 사용 불가.
- ListIterator: 양방향으로 이동하기 때문에 각 요소간의 이동이 자유롭다.
  
    → 이동하기 전에 `Next()`, `hasPrevious()` 호출해서 이동할 수 있는지 확인해야 한다.
    

<br>

<br>

### 6) Arrays

→ 배열을 다루는데 유 용한 메서드가 정의되어 있다. 같은 기능의 메서드가 배열의 타입만 다르게 오버로딩 되어 있어서 많이 보이지만, 실제로는 그리 많지 않다.

> Arrays에 정의된 메서드는 모두 `static` 메서드이다.
> 

```java
static String toString(boolean[] a)
static String toString(byte[] a)
static String toString(char[] a)
static String toString(short[] a)
static String toString(int[] a)
static String toString(long[] a)
static String toString(float[] a)
static String toString(double[] a)
static String toString(Object[] a)
```

<br>

**배열의 복사 - copyOf(), copyOfRange()**

- `copyOf()`: 배열 전체 복사
- `copyOfRange()`: 배열의 일부를 복사 (지정된 범위의 끝은 포함X)

```java
int[] arr = [0, 1, 2, 3 4];
int[] arr2 = Arrays.copyOf(arr, arr.length);  // arr2 = [0, 1, 2, 3, 4]
int[] arr3 = Arrays.copyOf(arr, 3);           // arr3 = [0, 1, 2]
int[] arr4 = Arrays.copyOf(arr, 7);           // arr4 = [0, 1, 2, 3, 4, 0, 0]
int[] arr5 = Arrays.copyOfRange(arr, 2, 4);   // arr5 = [2, 3] <- 4는 미포함
int[] arr6 = Arrays.copyOfRange(arr, 0, 7);   // arr6 = [0, 1, 2, 3, 4, 0, 0]
```

<br>

<br>

**배열 채우기 - fill(), setAll()**

- `fill()`: 배열의 모든 요소를 지정된 값을 채운다.
- `setAll()`: 배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받는다.
  
    → 이 메서드를 호출할 때는 함수형 인터페이스를 구현한 객체를 `매개변수`로 지정 or `람다식` 을 지정
    

```java
int[] arr = new int[5];
Arrays.fill(arr, 9);      // arr = [9, 9, 9, 9, 9]
Arrays.setAll(arr, () -> (int) (Math.random() * 5) + 1); // arr = [1, 5, 2, 1, 1]
```

<br>

<br>

**배열의 정렬과 검색 - sort(), binarySearch()**

- `sort()`: 배열을 정렬할 때 사용
- `binarySeach()`: 배열에 저장된 요소를 검색할 때 사용
  
    → 배열에서 지정된 값이 저장된 위치(index)를 찾아서 반환.
    → 반드시 배열이 정렬된 상태여야 올바른 결과를 얻는다.
    
    → IF. 검색한 값과 일치하는 요소들이 여러 개 있다면, 어떤 것의 위치가 반환될지는 알 수 없다.
    

```java
int[] arr = { 3, 2, 0, 1, 4 };
int idx = Arrays.binarySearch(arr, 2);      // idx = -5 <- 잘못된 결과

Arrays.sort(arr);
System.out.println(Arrays.toString(arr));   // [0, 1, 2, 3, 4]
int idx = Arrays.binarrySearch(arr, 2);     // idx = 2 <- 올바른 결과
```

- `순차 검색(linear search)`: 배열의 첫 번째 요소부터 순서대로 하나씩 검색하는 것
  
    → 배열이 정렬되어 있을 필요는 없지만 배열의 요소를 하나씩 비교하기 때문에 시간이 많이 걸림
    
- `이진 검색(binary search)`: 배열의 검색할 범위를 반복적으로 절반씩 줄어가면서 검색하기 떄문에 검색속다가 빠르다.
  
    → But, 배열이 정렬이 되어 있는 경우에만 사용할 수 있다는 단점이 있다.
    

<br>

<br>

**배열의 비교와 출력 - equals(), toString()**

- `toString()`: 배열의 모든 요소를 문자열로 편하게 출력할 수 있다.
  
    → 일차원 배열에만 사용할 수 있다. 다차원 배열에는 `deepTo String()`
    
- `deepTo String()`: 배열의 모든 요소를 재귀적으로 접근해서 문자열을 구성. 다차원 배열에서 사용 가능

```java
int[] arr = { 0, 1, 2, 3, 4 };
int[][] arr2D = { {11, 12}, {21, 22} };

System.out.println(Arrays.toString(arr));       // [0, 1, 2, 3, 4]
System.out.println(Arrays.deepToString(arr2D)); // [[11, 12], [21, 22]]
```

<br>

- `equals()`: 두 배열에 저장된 모든 요소를 비교해서 같으면 `true`, 다르면 `false` 를 반환

    → 일차원 배열에만 사용가능. 다차원 배열에는 `deepTo String()`


```java
String[][] str2D = new String[][] {{"aaa", "bbb"], {"AAA", "BBB"}};
String[][] str2D2 = new String[][] {{"aaa", "bbb"}, {"AAA", "BBB"}};

System.out.println(Arrays.equals(str2D, str2D2D));    // false
System.out.println(Arrays.deepEquals(str2D, str2D2)); // true
```

<br>

다차원 배열은 ‘배열의 배열’의 형태로 구성하기 때문에 `equals()` 로 비교하면, 문자열을 비교하는 것이 아니라 ‘배열에 저장된 배열의 주소’를 비교하게 된다. 서로 다른 배열은 항상 주소가 다르므로 `false` 를 결과로 얻는다.

<br>

<br>

**배열을 List로 변환 - asList(Object... a)**

- `asList()`: 배열을 List에 담아서 반환한다. 매개변수의 타입이 가변인수라서 배열 생성없이 저장할 요소들만 나열하는 것도 가능

```java
Lsit list = Arrays.asList(new Integer[]{1, 2, 3, 4, 5}}; // list = {1, 2, 3, 4, 5}
List list = Arrays.asList(1, 2, 3, 4, 5);                // list = {1, 2, 3, 4, 5}
list.add(6); // UnsupportedOperationException 예외 발생
```

<br>

<br>

**!주의할 점**

`asList()` 가 반환한 List의 크기를 변경할 수 없다. 즉, 추가 또는 삭제가 불가능하다. 저장된 내용은 변경가능하다.

IF. 크기를 변경할 수 있는 리스트가 필요하다면?

```java
List list = new ArrayList(Arrays.asList(1, 2, 3, 4, 5));
```

<br>

<br>

**parallelXXX(), spliterator(), stream()**

- `parallel`: 시작하는 이름의 메서드들이 있는데, 이 메서드들은 보다 빠른 결과를 얻기 위해 여러 쓰레드가 작업을 나누어 처리하도록 한다.
- `spliterator()`: 여러 쓰레드가 처리할 수 있게 하나의 작업을 여러 작업으로 나누는 `Spliterator` 를 반환.
- `stream()`: 컬렉션을 스트림으로 변환

<br>

<br>

### 7) Comparator와 Comparable

`Arrays.sort()` 를 호출하면 알아서 배열을 정렬하는 것처럼 보이지만, Character클래스의 Comparable의 구현에 의해 정렬되어있던 것이다.

`Comparator` 와 `Comparable` 은 모두 인터페이스로 컬렉션을 정렬하는데 필요한 메서드를 정의하고 있으며, Comparable을 구현하고 있는 클래스들은 같은 타입의 인스턴스끼리 서로 비교할 수 있는 클래스들, 주로 Integer와 같은 wrapper클래스와 String, Date, File과 같은 것들이며 기본적으로 오름차순 (작은 값에서 큰 값의 순) 으로 정렬되도록 구현되어 있다.

- `Comparable`: 기본 정렬기준을 구현하는데 사용
- `COmparator`: 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용

<br>

<br>

### 8) HashSet

: HashSet은 Set인터페이스를 구현한 가장 대표적인 컬렉션. HashSet은 중복된 요소를 저장하지 않는다.

- 새로운 요소를 추가할 때: `add`, `addAll`
  
    → 이미 저장되어 있는 요소와 중복된 요소를 추가하고자 한다면 이 메서드들은 false를 반환함으로써 중복된 요소이기 때문에 추가에 실패했다는 것을 알림
    
- HashSet은 저장순서를 유지하지 않으므로 저장순서를 유지하고자 한다면 `LinkedHashSet` 을 사용

> HashSet은 내부적으로 HashMap을 이용해서 만들어졌으며, HashSet이란 이름은 해싱(Hashing)을이용해서 구현했기 때문에 붙여진 이름.
> 

<br>

<br>

**HashSet의 메서드**

| 생성자 또는 메서드                             | 설명                                                         |
| ---------------------------------------------- | ------------------------------------------------------------ |
| HashSet()                                      | HashSet 객체를 생성한다.                                     |
| HashSet(Collection c)                          | 주어진 컬렉션을 포함하는 HashSet 객체를 생성한다.            |
| HashSet(int initialCapacity)                   | 주어진 값을 초기용량으로하는 HashSet 객체를 생성             |
| HashSet(int initialCapacity, float loadFactor) | 초기용량과 load factor를 지정하는 생성자                     |
| boolean add(Object o)                          | 새로운 객체를 저장한다.                                      |
| boolean addAll(Collection c)                   | 주어진 컬렉션에 저장된 모든 객체들을 추가한다.(합집합)       |
| void clear()                                   | 저장된 모든 객체를 삭제한다.                                 |
| Ojbect clone()                                 | HashSet을 복제해서 반환한다.(얕은 복사)                      |
| boolean contains(Obejct o)                     | 지정된 객체를 포함하고 있는지 알려준다.                      |
| boolean containsAll(Collection c)              | 주어진 컬렉션에 저장된 모든 객체들을 포함하고 있는지 알려준다. |
| boolean isEmpty()                              | HashSet이 비어있는지 알려준다.                               |
| Iterator iterator()                            | Iterator를 반환한다.                                         |
| boolean remove(Object o)                       | 지정된 객체를 HashSet에서 삭제한다. (성공하면 true, 실패하면 false) |
| boolean removeAll(Collection c)                | 주어진 컬렉션에 저장된 모든 객체와 동일한 것들을 HashSet에서 모두 삭제한다. (차집합) |
| boolean retainAll(Collection c)                | 주어진 컬렉션에 저장된 객체와 동일한 것만 남기고 삭제한다. (교집합) |
| int size()                                     | 저장된 객체의 개수를 반환한다.                               |
| Object[] toArray()                             | 저장된 객체들을 객체배열의 형태로 반환한다.                  |
| Object[] toArray(Obejct[] a)                   | 지정된 객체들을 주어진 객체배열(a)에 담는다.                 |



<br>

오버라이딩을 통해 작성된 `hashCode()` 는 다음의 세 가지 조건을 만족 시켜야 한다.

1. 실행 중인 애플리케이션 내의 동일한 객체에 대해서 여러 번 hashCode()를 호출해도 동일한 int값을 반환해야 한다. But, 실행시마다 동일한 int값을 반환할 필요는 없다.
   (단, equals의 구현에 사용된 멤버변수의 값이 바뀌지 않았다고 가정)
   
    Ex) Person2클래스의 equals메서드에 사용된 멤버변수 name과 age값이 바뀌지 않는 한, 하나의 Person2인스턴스에 대해 hashCode()를 여러 번 호출했을 때 항상같은 int값을 얻어야 한다.
   
    ```java
    Person2 p = new Person2("David", 10);
    
    int hashCode1 = p.hashCode();
    int hashCode2 = p.hashCode();
    
    p.age = 20;
    int hashCode3 = p.hashCode();
    ```
   
1. equals메서드를 이용한 비교에 의해서 true를 얻은 두 객체에 대해 각각 hashCode()를 호출해서 얻은 결과는 반드시 같아야 한다.
   Ex) 인스턴스 p1과 p2에 대해서 equals메서드를 이용한 비교의 결과인 변수 b의 값이 true라면, hashCode1과 hashCode2의 값은 같아야 한다는 뜻.
   
    ```java
    Person2 p1 = new Person2("David", 10);
    Person2 p2 = new Person2("David", 10);
    
    boolean b = p1.equals(p2);
    
    int hashCode1 = p1.hashCode();
    int hashCode2 = p2.hashCode();
    ```
   
2. equals메서드를 호출했을 때 false를 반환하는 두 객체는 hashCOde() 호출에 대해 같은 int값을 반환하는 경우가 있어도 괜찮지만, 해싱(hashing)을 사용하는 컬렉션의 성능을 향상시키기 위해서는 다른 int값을 반환하는 것이 좋다.
Ex) 위의 코드에서 변수 b의 값이 false일지라도 hashCode1과 hashCode2의 값이 같은 경우가 발생하는 것을 허용. But, 해시코드를 사용하는 HashTable이나 HashMap과 같은 컬렉션의 성능을 높이기 위해서는 가능한 한 서로 다른 값을 반환하도록 hashCode()를 잘 작성해야 한다는 뜻

<br>

<br>

### 9) TreeSet

: 이진 검색 트리(binary search tree)라는 자료구조의 형태로 데이터를 저장하는 컬렉션 클래스.

- 이진 검색 트리: 정렬, 검색, 범위검색(range search)에 높은 성능을 보이는 자료구조
- TreeSet: 이진 검색 트리의 성능을 향상시킨 ‘레드 - 블랙 트리(Red-Black tree)’로 구현

Set 인터페이스를 구현했으므로 **중복된 데이터의 저장을 허용하지 않으며 정렬된 위치에 저장하므로 저장순서를 유지하지도 않는다.**

```java
                   루트(root)
                 /           \
              부모             ㅇ
             /   \             \
         A의 자식   A의 자식
            B        C           o
```

```java
class TreeNode {
		TreeNode left;       // 왼쪽 자식 노드
		Object   element;    // 객체를 저장하기 위한 참조변수
		TreeNode right;      // 오른쪽 자식 노드
}
```

```java
            5                  0x100|5|0x200
          /   \               /             \
         1     7       null|1|null        null|7|null
                       0x100              0x200
```

<br>

**Ex) 이진검색트리에 7, 4, 9, 1, 5의 순서로 값을 저장한다고 가정하자.**

```java
    1.저장            1비교(4<7)                 1비교(9>7)
      7      ->          7          ->            7
                        /                       /   \ 2저장
                    2저장                      4       9
                     4

              1비교(1<7)                        1비교(5<7)
->            /        \            ->        /         \
        2비교(1<4)       9               2비교(5>4)         9
            4                               4
           /                              /   \
       3저장                              1     3저장
        1                                       5
```

<br>

첫 번째로 저장되는 값은 루트가 되고, 두 번째 값은 트리의 루트부터 시작해서 값의 크기를 비교하면서 트리를 따라 내려간다. 작은 값은 왼쪽에 큰 값은 오른쪽에 저장한다.

→ 트리를 구성하면, 왼쪽 마지막 레벨이 제일 작은 값이 되고 오른쪽 마지막 레벨의 값이 제일 큰 값이 된다.

<br>

<br>

**Tree**

- 데이터를 순차적으로 저장X, 저장위치를 찾아서 저장해야 한다.
- 삭제하는 경우, 트리의 일부를 재구성해야하므로 LinkedList보다 데이터의 추가/삭제 시간은 더 걸린다.
- 배열이나 링크드 리스트에 비해 검색과 정렬기능이 더 뛰어나다.

<br>

<br>

**이진 검색 트리(binary search tree)**

- 모든 노드는 최대 두 개의 자식노드를 가질 수 있다.
- 왼쪽 자식노드의 값은 부모노드의 값보다 작고 오른쪽자식노드의 값은 부모노드의 값보다 커야 한다.
- 노드의 추가 삭제에 시간이 걸린다. (순차적으로 저장하지 않으므로)
- 검색(범위검색)과 정렬에 유리하다.
- 중복된 값을 저장하지 못한다.

<br>

<br>

**TreeSet의 생성자와 메서드**

| 생성자 또는 메서드                                           | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| TreeSet()                                                    | 기본 생성자                                                  |
| TreeSet(Collection c)                                        | 주어진 컬렉션을 저장하는 TreeSet을 생성                      |
| TreeSet(Comparator comp)                                     | 주어진 정렬조건으로 정렬하는 TreeSet을 생성                  |
| TreeSet(SortedSet s)                                         | 주어진 SortedSet을 구현한 컬렉션을 저장하는 TreeSet을 생성   |
| boolean add(Object o), <br />boolean addAll(Collection c)    | 지정된 객체(o) 또는 Collection(c)의 객체들을 Collection에 추가 |
| Object celling(Object o)                                     | 지정된 객체와 같은 객체를 반환. 없으면 큰 값을 가진 객체 중 제일 가까운 값의 객체를 반환. 없으면 null |
| void clear()                                                 | 저장된 모든 객체를 삭제한다.                                 |
| Object clone()                                               | TreeSet을 복제하여 반환한다.                                 |
| Comparator comparator()                                      | TreeSet의 정렬기준(Comparator)를 반환한다.                   |
| boolean contains(Object o), <br />boolean containsAll(Collection c) | 지정된 객체(o) 또는 Collection의 객체들이 포함되어 있는지 확인한다. |
| NavigableSet descendingSet()                                 | TreeSet에 지정된 요소들을 역순으로 정렬해서 반환             |
| Object first()                                               | 정렬된 순서에서 첫 번째 객체를 반환한다.                     |
| Object floor(Object o)                                       | 지정된 객체와 같은 객체를 반환. 없으면 작은 값을 가진 객체 중 제일 가까운 값의 객체를 반환. 없으면 null |
| SortedSet headSet(Object toElement)                          | 지정된 객체보다 작은 값의 객체들을 반환한다.                 |
| NavigableSet headSet(Object toElement, boolean inclusive)    | 지정된 객체보다 작은 값의 객체들을 반환 inclusive가 true이면, 같은 값의 객체도 포함 |
| Object higher(Object o)                                      | 지정된 객체보다 큰 값을 가진 객체 중 제일 가까운 값의 객체를 반환. 없으면 null |
| boolean isEmpty()                                            | TreeSet이 비어있는지 확인한다.                               |
| Iterator iterator()                                          | TreeSet의 Iterator를 반환한다.                               |
| Object last()                                                | 정렬된 순서에서 마지막 객체를 반환한다.                      |
| Object lower(Object o)                                       | 지정된 객체보다 작은 값을 가진 객체 중 제일 가까운 값의 객체를 반환. 없으면 null |
| Object pollFirst()                                           | TreeSet의 첫번쨰 요소(제일 작은 값의 객체)를 반환            |
| Object pollLast()                                            | TreeSet의 마지막 번째 요소(제일 큰 값의 객체)를 반환         |
| boolean remove(Object o)                                     | 지정된 객체를 삭제한다.                                      |
| boolean retainAll(Collection c)                              | 주어진 컬렉션과 공통된 요소만을 남기고 삭제한다. (교집합)    |
| int size()                                                   | 저장된 객체의 개수를 반환                                    |
| Spliterator spliterator()                                    | TreeSet의 spliterator를 반환                                 |
| SortedSet subSet(Object tromElement, Object toElement)       | 범위 검색(fromElement와 toElement사이)의 결과를 반환한다. <br />(끝 범위인 toElement는 범위에 포함되지 않음) |
| NavigableSet<E> subSet(E tromElement, boolean frominclusive, E toElement, boolean toinclusive) | 범위 검색(fromElement와 toElement사이)의 결과를 반환한다. <br />(frominclusize가 true면 시작값이 포함되고, toinclusive가 true면 끝값이 포함된다.) |
| SortedSet tailSet(Object fromElment)                         | 지정된 객체보다 큰 값의 객체들을 반환한다.                   |
| Object[] toArray()                                           | 지정된 객체를 객체배열로 반환한다.                           |
| Object[] toArray(Object[] a)                                 | 저장된 객체를 주어진 객체배열에 저장하여 반환한다.           |



<br>

<br>

### 10) HashMap과 HashTable

: Vector와 ArrayList의 관계와 같아서 Hashtable보다는 새로운 버전인 HashMap을 사용할 것을 권한다.

- HashMap: Map을 구현했으므로, Map의 특징, 키(Key)와 값(Value)을 묶어서 하나의 데이터(entry)로 저장한다는 특징을 갖는다. 그리고 해싱(hashing)을 사용하기 때문에 많은 양의 데이터를 검색하는데 있어서 뛰어난 성능을 보인다.

```java
public class HashMap extends AbstractMap implements Map, Cloneable, Serializable {

		transient Entry[] table;
				...
		static class Entry implements Map.Entry {
				final Object key;
				Object value;
						...
		}
}
```

```java
// 비객체지향적인 코드
Object[] key;
Object[] value;

// 객체지향적인 코드
Entry[] table;
class Entry {
		Object key;
		Object value;
}
```

- 키(Key): 컬랙션 내의 키(ekY) 중에서 유일하게 한다.
- 값(value): 키(Key)와 달리 데이터의 중복을 허용한다.

<br>

<br>

**HashMap의 생성자와 메서드**

| 생성자 / 메서드 | 설명 |
| --- | --- |
| HashMap() | HashMap객체를 설명 |
| HashMap(int initialCapacity) | 지정된 값을 초기용량으로 하는 HashMap 객체를 생성 |
| HashMap(int initialCapacity, float loadFactor) | 지정된 초기 용량과 load factor의 HashMap을 생성 |
| HashMap(Map m) | 지정된 Map의 모든 요소를 퐇마하는 HashMap을 생성 |
| void clear() | HashMap에 저장된 모든 객체를 제거 |
| Object clone() | 현재 HashMap을 복제해서 반환 |
| boolean containsKey(Object key) | HashMap에 지정된 키(key)가 포함되어있는지 알려준다. (포함되어 있으면 true) |
| boolean containsValue(Object value) | HashMap에 지정된 값(value)가 포함되어있는지 알려준다. (포함되어 있으면 true) |
| Set entrySet() | HashMap에 저장된 키와 값을 엔트리(키와 값의 결합)의 형태로 Set에 저장해서 반환 |
| Object get(Object key) | 지정된 키(key)의 값(객체)을 반환. 못찾으면 null 반환 |
| Object getOrDefault(Object key, Object defaultValue) | 지정된 키(key)의 값(객체)을 반환한다. 키를 못찾으면, 기본값(defaultValue)로 지정된 객체를 반환 |
| boolean isEmpty() | HashMap이 비버있는지 알려준다. |
| Set keySet() | HashMap에 저장된 모든 키가 저장된 Set을 반환 |
| Object put(Object key, Object value) | 지정된 키와 값을 HashMap에 저장 |
| void putAll(Map m) | Map에 저장된 모든 요소를 HashMap에 저장 |
| Object remove(Object key) | HashMap에서 지정된 키로 저장된 값(객체)를 제거 |
| Object replace(Object key, Object value) | 지정된 키의 값을 지정된 객체(value)로 대체 |
| boolean replace(Object key, Object oldValue, Object newValue) | 지정된 키와 객체(oldValue)가 모두 일치하는 경우에만 새로운 객체(newValue)로 대체 |
| int size() | HashMap에 저장된 요소의 개수를 반환 |
| Collection value() | HashMap에 저장된 모든 값을 컬렉션의 형태로 반환 |

<br>

<br>

### 해싱과 해시함수

- 해싱: 해시함수(Hash Function)를 이용해서 데이터를 해시테이블(hash table)에 저장하고 검색하는 기법 
→ 해싱을 구현한 컬렉션 클래스: HashSet, HashMap, HashTable 등이 있다.
→ 가능하다면 Hashtable대신 HashMap을 사용하자.
- 해시함수: 데이터가 저장되어 있는 곳을 알려 주기 때문에 다양한 데이터 중에서도 원하는 데이터를 빠르게 찾을 수 있다.

<br>

![picture](https://github.com/JaeYeon33/TIL/blob/main/JAVA/image/Untitled%2022.png?raw=true)



<br>

<br>

![picture](https://github.com/JaeYeon33/TIL/blob/main/JAVA/image/Untitled%2023.png?raw=true)



<br>

<br>

1) 키로 해시함수를 호출해서 해시코드를 얻는다.

2) 해시코드(해시함수의 반환값)에 대응하는 Linked List를 배열에서 찾는다.

3) LinkedList에서 키와 일치하는 데이터를 찾는다.
   - 해시함수는 같은 키에 대해 항상 같은 해시코드를 반환해야 한다. 서로 다른 키일지라도 같은 값의 해시코드를 반환할 수 있다.



<br>

<br>



### 11) TreeMap

: 이진검색트리의 형태로 키와 값이 쌍으로 이루어진 데이터를 저장. 그래서 <u>검색과 정렬에 적합한 컬렉션 클래스</u>

<br>

검색에 관한한 대부분의 경우에서 HashMap이 TreeMap보다 뛰어나므로 HashMap을 사용하는 것이 좋다.

But, 검색범위나 정렬이 필요한 경우 TreeMap 사용

<br>

<br>

### TreeMap의 생성자와 메서드

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| TreeMap()                                                    | TreeMap객체를 생성                                           |
| TreeMap(Comparator c)                                        | 지정된 Comparator를 기준으로 정렬하는 TreeMap 객체를 생성    |
| TreeMap(Map m)                                               | 주어진 Map에 저장된 모든 요소를 포함하는 TreeMap을 생성      |
| TreeMap(SortedMap m)                                         | 주어진 SortedMap에 저장된 모든 요소를 포함하는 TreeMap을 생성 |
| Map.Entry ceilingEntry(Object key)                           | 지정된 key와 일치하는 큰 것중 제일 작은 것의 키와 값의 쌍(Map.Entry)를 반환. 없으면 null을 반환 |
| Object ceilingKey(Object key)                                | 지정된 key와 일치하거나 큰 것중 제일 작은 것의 키를 반환. 없으면 null 반환 |
| void clear()                                                 | TreeMap에 저장된 모든 객체를 제거                            |
| Object clone()                                               | 현재 TreeMap을 복제해서 반환                                 |
| Comparator comparator()                                      | TreeMap의 정렬 기준이 되는 Comparator를 반환                 |
| COmparator가 지정되지 않았다면 null을 반환                   |                                                              |
| boolean containsKey(Object key)                              | TreeMap에 지정된 키(key)가 포함되어있는지 알려줌             |
| (포함되어 있으면 true)                                       |                                                              |
| boolean containsValue(Object value)                          | TreeMap에 지정된 값(value)가 포함되어있는지 알려줌           |
| (포함되어 있으면 true)                                       |                                                              |
| NavigableSet descendingKeySet()                              | TreeMap에 저장된 키를 역순으로 정렬해서 NavigableSet에 담아서 반환 |
| Set entrySet()                                               | TreeMap에 저장된 키와 값을 엔트리(키와 값의 결합)의 형태로 Set에 저장해서 반환 |
| Map.Entry firstEntry()                                       | TreeMap에 저장된 첫번째 (가장 작은) 키와 값의 쌍(Map.Entry)을 반환 |
| Object floorKey(Object key)                                  | 지정된 key와 일치하거나 작은 것 중에서 제일 큰 키를 반환. 없으면 null을 반환 |
| Object get(Object key)                                       | 지정된 키(key)의 값(객체)을 반환                             |
| SortedMap headMap(Object toKey)                              | TreeMap에 저장된 첫번째 요소부터 지정된 범위에 속한 모든 요소가 담긴 SortedMap을 반환(toKey는 미포함) |
| NavigableMap headMap(Object toKey, boolean inclusive)        | TreeMap에 저장된 첫번째 요소부터 지정된 범위에 속한 모든 요소가 담긴 SortedMap을 반환.inclusive의 값이 true면 toKey도 포함 |
| Map.Entry higherEntry(Object key)                            | 지정된 key보다 큰 키 중에서 제일 작은 키의 쌍(Map.Entry)을 반환. 없으면 null을 반환. |
| Object highterKey(Object Key)                                | 지정된 key보다 큰 키 중에서 제일 작은 키의 쌍(Map.Entry)를 반환. 없으면 null을 반환. |
| boolean isEMpty()                                            | TreeMap이 비어있는지 알려준다.                               |
| Set keySet()                                                 | TreeMap에 저장된 모든 키가 저장된 Set을 반환.                |
| Map.Entry lastEntry()                                        | TreeMap에 저장된 마지막 키(가장 큰 키)의 쌍을 반환.          |
| Object lastKey()                                             | TreeMap에 저장된 마지막 키(가장 큰 키)를 반환.               |
| Map.Entry lowerEntry(Object key)                             | 지정된 key보다 작은 키 중에서 제일 큰 키의 쌍(Map.Entry)을 반환. 없으면 null을 반환. |
| Object lowerKey(Object key)                                  | 지정된 key보다 작은 키 중에서 제일 큰 키의 쌍(Map.Entry)를 반환. 없으면 null을 반환. |
| NavigableSet navigableKeySet()                               | TreeMap에서 모든 키가 담긴 NavigabelSet을 반환.              |
| Map.Entry pollFirstEntry()                                   | TreeMap에서 제일 작은 키를 제거하면서 반환.                  |
| Map.Entry pollLastEntry()                                    | TreeMap에서 제일 큰 키를 제거하면서 반환.                    |
| Object pull(Object key, Object value)                        | 지정된 키와 값을 TreeMap에 저장.                             |
| void putAll(Map map)                                         | Map에 저장된 모든 요소를 TreeMap에 저장.                     |
| Object remove(Object key)                                    | TreeMap에서 지정된 키로 저장된 값(객쳬)를 변경.              |
| Object replace(Object k, Object v)                           | 기존의 키(k)의 값을 지정된 값(v)으로 변경.                   |
| boolean replace(Object key, Object oldValue, Object newValue) | 기존의 키(k)의 값을 새로운 값(newValue)으로 변경.            |
| 단, 기존의 값과 지정된 값(oldValue)가 일치해야 함            |                                                              |
| int size()                                                   | TreeMap에 저장된 요소의 개수를 반환.                         |
| NavigableMap subMap(Object fromKey, boolean frominclusive, Object toKey, boolean toInclusive) | 지정된 두 개의 키 사이에 있는 모든 요소들이 담긴 NavagableMap을 반환. frominclusive가 true면 범위에 fromKey포함. toinclusive가 true면 범위에 toKey포함. |
| SortedMap subMap(Object fromKey, Object toKey)               | 지정된 두 개의 키 사이에 있는 모든 요소들이 담긴 SortedMap을 반환(toKey는 포함되지 않는다.) |
| SortedMap tailMap(Object fromKey)                            | 지정된 키부터 마지막 요소의 범위에 속한 요소가 담긴 SortedMap을 반환 |
| NavigableMap tailMap(Object fromKey, boolean inclusive)      | 지정된 키부터 마지막 요소의 범위에 속한 요소가 담긴 NavigableMap을 반환. inclusive가 true면 fromKey포함 |
| Collection values()                                          | TreeMap에 저장된 모든 값을 컬렉션의 형태로 반환              |

<br>

<br>

### 12) Properties

: HashMap의 구버전인 Hashtable을 상속받아 구현한 것.

- HashTable: 키와 값(Object, Object)의 형태로 저장
- Properties: (String, String)

<br>

<br>

### 13) Collections

: 컬렉션과 관련된 메서드를 제공한다. `fill()`, `copyt()`, `sort()`, `binarySearch()`

<br>

<br>

### 컬렉션의 동기화

멀티 쓰레드 프로그래밍에서는 한의 객체를 여러 쓰레드가 동시에 접근할 수 있기 때문에 데이터의 일관성(consistency)을 유지하기 위해서는 공유되는 객체에 동기화(synchronization)가 필요.

<br>

Vactor와 Hashtable 같은 구버전(JDK1.2)의 클래스들은 자체적으로 동기화되어 있다.

But, 멀티쓰레드가 아닌 경우에는 불필요한 기능이 되어 성능을 떨어뜨림.

<br>

ArrayList와, HashMap과 같은 컬렉션은 동기화를 자체적으로 동기화 처리가 되어 있는데, 필요한 경우에만 Collections클래스의 동기화 메서드를 이용해서 동기화처리가 가능하도록 변경.

<br>

Collections클래스에는 동기화 메서드를 제공하고 있다.

```java
static Collection synchronizedCollection (Collection c)
static List       synchronizedList (List list)
static Set        synchronizedSet (Set s)
static Map        synchronizedMap (Map m)
static SortedSet  synchronizedSortedSet (SortedSet s)
static SortedMap  synchronizedSortedMap (SortedMap m)
```

<br>

**사용방법**

```java
List syncList = Collections.synchronizedList(new ArrayList(...));
```

<br>

<br>

### 변경불가 컬렉션 만들기

컬렉션에 저장된 데이터를 보호가기 위해서 컬렉션을 변경할 수 없게, 읽기전용으로 만들어야 할 떄가 있다.

주로 멀티 쓰레드 프로그래밍에서 여러 쓰레드가 하나의 컬렉션을 공유하다보면 데이터가 손상될 수 있는데, 이를 방지하려면 메서드를 이용.

```java
static Colleciton    unmodifiableSet (Collection c)
static List          unmodifiableList (List list)
static Set           unmodifiableSet (Set s)
static Map           unmodifiableMap (Map m)
static NavigableSet  unmodifiableNavigableSet (NavigableSet s)
static SortedSet     unmodifiableSortedSet (SortedSet s)
static HavigableMap  unmodifiableHavigableMap (HavigableMap m)
static SortedMap     unmodifiableSortedMap (SortedMap m)
```

<br>

<br>

### 싱글톤 컬렉션 만들기

단 하나의 객체만을 저장하는 컬렉션을 만들고 싶은 경우

```java
static List singletonList (Object o)
static Set  singleton (Object o) // singletonSet이 아님
static Map  singletonMap (Object key, Object value)
```

매개변수로 저장할 요소를 저장하면, 해당 요소를 저장하는 컬렉션을 반환.

반환된 컬렉션은 변경할 수 없다.

<br>

<br>

### 한 종류의 객체만 저장하는 컬렉션 만들기

대부분의 경우 한 객체를 저장하며, 컬렉션에 지정된 종류의 객체만 저장할 수 있도록 제한하고 싶을 때 사용

```java
static Collection   checkedCollection (Collection c, Class type)
static List         checkedList (List list, Class type)
static Set          checkedSet (Set s, Class type)
static Map          checkedMap (Map m, Class keyType, Class valueType)
static Queue        checkedQueue (Queue queue, Class type)
static NavigableSet checkedNavigableSet (NaviagbleSet s, Class type)
static SortedSet    checkedSortedSet (SortedSet s, Class type)
static NavigableMap checkedNavigableMap (NavigableMap m, Class keyType, Class valueType)

static SortedMap    checkedSortedMap (SortedMap m, Class keyType, Class valueType)
```

<br>

<br>

**사용방법**

```java
List list = new ArrayList();
List checkedList = checkedList(list, String.class); // String만 저장가능
checkedList.add("abc");          // OK.
checkedList.add(new Integer(3)); // ERROR. ClassCastException 발생
```

<br>

<br>

### 14. 컬렉션 클래스 정리 & 요약

![picture](https://github.com/JaeYeon33/TIL/blob/main/JAVA/image/Untitled%2024.png?raw=true)

<br>

<br>

| 컬렉션        | 특징                                                         |
| ------------- | ------------------------------------------------------------ |
| ArrayList     | 배열기반. 데이터의추가와 삭제에 불리. 순차적인 추가삭제는 제일 빠름. 읨의의 요소에 대한 접근성(accessibility)이 뛰어남 |
| LinkedList    | 연결기반. 데이터의 추가와 삭제에 유리. 임의의 요소에 대한 접근성이 좋지 않다. |
| HashMap       | 배열과 연결이 결합된 형태. 추가, 삭제, 검색, 접근성이 모두 뛰어남. 검색에는 최고성능을 보인다. |
| TreeMap       | 연길기반. 정렬과 검색(특히 범위검색)에 적합. 검색성능은 HashMap보다 멀어짐 |
| Stack         | Vector를 상속받아 구현                                       |
| Queue         | LinkedList가 Queue인터페이스를 구현                          |
| Properties    | HashTable을 상속받아 구현                                    |
| HashSet       | HashMap을 이용해서 구현                                      |
| TreeSet       | TreeMap을 이용해서 구현                                      |
|               | LinkedHashMap                                                |
| LInkedHashSet | HashMap과 HashSet에 저장순서유지기능을 추가                  |