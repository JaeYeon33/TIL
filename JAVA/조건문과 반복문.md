## 1. 조건문 - if, switch

---

조건문은 조건식과 문장을 포함하는 블럭 `{}` 으로 구성되어 있으며, 조건식의 연산결과에 따라 실행할 문장이 달라져서 프로그램의 실행흐름을 변경할 수 있다.

조건문은 if문과 switch문, 두 가지가 있으며 주로 if문이 많이 사용된다. 처리할 경우의 수가 많을 때는 if문보다 switch문이 효율적이지만, switch문은 if문보다 제약이 많다.

<br>

<br>

### 1) if문

if문 가장 기본적인 조건문이며, 다음과 같이 '조건식'과 '괄호 {}'로 이루어져 있다.

`만일(if) 조건식이 참(true)이면 괄호 {} 안의 문장들을 수행하라`

```java
if (조건식) {
		// 조건식이 참(true)일 때 수행될 문장들을 적는다.
}
```

```java
if (score > 60) {
		System.out.println("합격입니다.");
}
```

<br>

위 if문의 조건식이 평가되는 과정을 단계별로 살펴보면 다음과 같다.

```java
score > 60
-> 80 > 60
-> true
```

<br>

**자주 사용되는 조건식**

| 조건식                                    | 조건식이 참인 조건                                 |
| ----------------------------------------- | -------------------------------------------------- |
| 90 <= x && <= 100                         | 정수 x가 90이상 100이하 일 때                      |
| x < 0 \|\| x > 100                        | 정수 x가 0보다 작거나 100보다 클 때                |
| x % 3 == 0 && x % 2!= 0                   | 정수 x가 3의 배수지만, 2의 배수는 아닐 때          |
| ch == 'y' \|\| ch == 'Y'                  | 문자 ch가 'y' 또는 'Y' 일 때                       |
| ch == ' ' \|\| ch == '\t' \|\| ch == '\n' | 문자 ch가 공백이거나 탭 또는 개행 문자일 때        |
| 'A' <= ch && ch <= 'Z'                    | 문자 ch가 대문자일 때                              |
| 'a' <= ch && ch <= 'z'                    | 문자 ch가 소문자일 때                              |
| '0' <= ch && ch <= '9'                    | 문자 ch가 숫자일 때                                |
| str.equals("yes")                         | 문자열 str의 내용이 "yes"일 때 (대소문자 구분)     |
| str.equalsIgnoreCase("yes")               | 문자열 str의 내용이 "yes"일 때 (대소문자 구분안함) |



<br>

조건식을 작성할 때 실수하기 쉬운 것이, 등가비교 연산자 '==' 대신 대입 연산자 '='를 사용하는 것이다.

```java
if (x = 0) { ... } // x에 0이 저장되고, 결과는 0이 된다.
-> if (0)  { ... } // 결과가 true 또는 false가 아니므로 에러가 발생한다.
```

자바에서 조건식의 결과는 반드시 true 또는 false이어야 한다는 것을 잊지 말자.

<br>

<br>

### 블럭 {}

괄호 {}를 이용해서 여러 문장을 하나의 단위로 묶을 수 있는데, 이것을 `블럭(block)` 이라고 한다.

블럭 내의 문장들은 탭(tab)으로 들여쓰기(indentation)를 해서 블럭 안에 속한 문장이라는 것을 알기 쉽게 해주는 것이 좋다.

```java
if (score > 60) {
	System.out.println("합격입니다.");
}
```

<br>

블럭 안에는 보통 여러 문장을 넣지만, 한 문장만 넣거나 아무런 문장도 넣지 않을 수 있다. 만일 블럭 내의 문장이 하나뿐 일 때는 아래와 같이 괄호{}를 생략할 수 있다.

```java
if (score > 60)
	System.out.println("합격입니다");
```

<br>

또는 아래와 같이 한 줄로 쓸 수도 있다.

```java
if (score > 60) System.out.println("합격입니다.");
```

<br>

이처럼 블럭 내의 문장이 하나뿐인경우 괄호{}를 생략할 수 있지만 가능하면 생략하지 않고 사용하는 것이 바람직하다. 나중에 새로운 문장들이 추가되면 괄호{}로 문장들을 감싸주어야 하는데, 이 때 괄호{}를 추가하는 것을 잊기 쉽기 때문이다.

```java
if (score > 60)
	System.out.println("합격입니다.");  // 문장1 if문에 속한 문장
	System.out.println("축하드립니다."); // 문장2 if문에 속한 문장이 아님
```

<br>

아래와 같이 괄호{}로 묶어줘야만 두 문장 모두 if문에 속한 문장이 된다.

```java
if (score > 60) {
	System.out.println("합격입니다.");  // 문장1. if문에 속한 문장
	System.out.println("축하드립니다."); // 문장2. if문에 속한 문장
}
```

<br>

<br>

### 2) if - else문

if문의 변형인 if-else문의 구조는 다음과 같다. 'else'의 뜻이 '그 밖의 다른' 이므로 조건식의 결과가 참이 아닐 때, 즉 거짓일 때 else 블럭의 문장을 수행하라는 뜻이다.

```java
if (조건식) {
	// 조건식이 참(true)일 때 수행될 문장들을 적는다.
} else {
	// 조건식이 거짓(false)일 때 수행될 문장들을 적는다.
}
```

<br>

if - else문 역시 블럭 내의 문장이 하나뿐인 경우 아래와 같이 괄호{}를 생략할 수 있다.

```java
if (input == 0)
	System.out.println("입력하신 숫자는 0입니다.");
else
	System.out.println("입력하신 숫자는 0이 아닙니다.");
```

<br>

### <br>

### 3) if - else - if문

if-else문은 두 가지 경우 중 하나가 수행되는 구조인데, 처리해야할 경우의 수가 셋 이상인 경우에는 어떻게 해야 할까? 그럴 때는 한 문장에 여러 개의 조건식을 쓸 수 있는 'if-else-if' 문을 사용하면 된다.

```java
if (조건식1) {
	// 조건식1의 연산결과가 참일 때 수행될 문장들을 적는다.
} else if (조건식2) {
	// 조건식2의 연산결과가 참일 때 수행될 문장들을 적는다.
} else if (조건식3) {
	// 조건식3의 연산결과가 참일 때 수행될 문장들을 적는다.
} else { // 마지막에는 보통 else블럭으로 끝나며, else블럭은 생략 가능하다.
	// 위의 어느 조건식도 만족하지 않을 때 수행될 문장들을 적는다.
}
```

<br>

<br>

### 4) 중첩 if문

if문의 블럭 내에 또 다른 if문을 포함시키는 것이 가능한데 이것을 중첩 if문이라고 부르며 중첩의 횟수에는 거의 제한이 없다.

```java
if (조건식1) {
	// 조건식1의 연산결과가 true일 때 수행될 문장들을 적는다.
	if (조건식2) {
		// 조건식1과 조건식2가 모두 true일 때 수행될 문장들
	} else {
		// 조건식1이 true이고, 조건식2가 false일 때 수행되는 문장들
	}
} else {
		// 조건식1이 false일 때 수행되는 문장들
}
```

위와 같이 내부의 if문은 외부의 if문보다 안쪽으로 들여쓰기를 해서 두 If문의 범위가 명확히 구분될 수 있도록 작성해야 한다.

<br>

<br>

### 5) switch문

if문은 조건식의 결과가 참과 거짓, 두 가지 밖에 없기 때문에 경우의 수가 많아질수록 else-if를 계속 추가해야하므로 조건식이 많아져서 복잡해지고, 여러 개의 조건식을 계산해야하므로 처리시간도 많이 걸린다.

<br>

이러한 if문과 달리 switch문은 단 하나의 조건식으로 많은 경우의 수를 처리할 수 있고, 표현도 간결하므로 알아보기 쉽다. 그래서 처리할 경우의 수가 많은 경우에는 if문 보다 switch문으로 작성하는 것이 좋다. 다만 switch문은 제약조건이 있기 때문에, 경우의 수가 많아도 어쩔 수 없이 if문으로 작성해야 하는 경우가 있다.

```java
switch (조건식) {
		case 값1 :
			// 조건식의 결과가 값1과 같을 경우 수행될 문장들
			// ...
			break;
		case 값2 :
			// 조건식의 결과가 값2와 같을 경우 수행될 문장들
			// ...
			break; // switch문을 벗어난다.
		// ...
		default:
			// 조건식의 결과와 일치하는 case문이 수행될 문장들
			// ...
}
```

<br>

만일 조건식의 결과와 일치하는 case문이 하나도 없는 경우에는 default문으로 이동한다. default문은 if문의 else 블럭과 같은 역할을 한다고 보면 이해가 쉬울 것이다. default문의 위치는 어디라도 상관 없으나 마지막에 놓기 때문에 `break문` 을 쓰지 않아도 된다.

<br>

그러나 경우에 따라서는 다음과 같이 고의적으로 break문을 생략하는 경우도 있다.

```java
switch (level) {
		case 3:
				grantDelete();   // 삭제권한을 준다.
		case 2:
				grantWrite();    // 쓰기권한을 준다.
		case 1:
				grantRead();     // 읽기권한을 준다.
```

<br>

위의 코드는 전체 코드가 아닌 코드의 일부를 발췌한 것인데, 회원제로 운영되는 웹사이트에서 많이 사용될 만한 코드이다.

<br>

<br>

### swtich문의 제약조건

switch문의 조건식은 결과값이 반드시 정수이어야 하며, 이 값과 일치하는 case문으로 이동하기 때문에 case문의 값 역시 정수이어야 한다. 그리고 중복되지 않아야 한다. 같은 값의 case문이 여러 개이면, 어디로 이동해야할 지 알 수 없기 때문이다.

게다가 case문은 반드시 상수이어야 한다. 변수나 실수, 문자열은 case문의 값으로 사용할 수 없다.

```java
switch문의 제약조건
1. switch문의 조건식 결과는 정수 또는 문자열이어야 한다.
2. case문의 값은 정수 상수만 가능하며, 중복되지 않아야 한다.
```

<br>

case문의 몇 가지 예를 아래의 코드에 적어보았다.

```java
public static void main(String[] args) {
		int num, result;
		final int ONE = 1;

		...

		switch (result) {
				case '1':    // OK. 문자 리터럴(정수 상수 49와 동일)
				case ONE:    // OK. 정수 상수
				case "YES":  // OK. 문자열 리터럴. JDK 1.7부터 허용
				case num:    // 에러. 변수는 불가
				case 1.0:    // 에러. 실수도 불가
				...
```

<br>

문자 '1'은 정수 49와 동일하므로 문제가 없고, ONE은 정수가 아닌 것처럼 보이지만, 'final'이 붙은 정수 상수이므로 case문의 값으로 적합하다. 그러나 변수나 실수 리터럴은 case문의 값으로 적합하지 않다.

```java
switch (month) {
    case 3:
    case 4:
    case 5:
        System.out.println("현재의 계절은 봄입니다.");
        break;
    case 6: case 7: case 8:
        System.out.println("현재의 계절은 여름입니다.");
        break;

    case 9: case 10: case 11:
        System.out.println("현재의 계절은 가을입니다.");
        break;

    default:
//            case 12: case 1: case 2:
        System.out.println("현재의 계절은 겨울입니다.");
}
```

<br>

이 예제를 if문으로 변경하면 다음과 같다.

```java
if (month == 3 || month == 4 || month == 5) {
		System.out.println("현재의 계절은 봄입니다.");
} else if (month == 6 || month == 7 || month == 8) {
		System.out.println("현재의 계절은 여름입니다.");
} else if (month == 9 || month == 10 || month == 11) {
		System.out.println("현재의 계절은 가을입니다.");
} else { // if (month == 12 || month == 1 || month == 2)
		System.out.println("현재의 계절은 겨울입니다.");
}
```

<br>

두 문장을 비교해보면, 이 예제에서는 if문보다 switch문이 더 알아보기 쉽고 간결하는 것을 알 수 있다.

<br>

<br>

### switch문의 중첩

if문처럼 switch문도 중첩이 가능하다. 한 가지 주의할 점은 중첩 switch문에서 break문을 빼먹기 쉽다는 것이다.

```java
switch (gender) {
    case '1': case '3':
        switch (gender) {
            case '1':
                System.out.println("당신은 2000년 이전에 출생한 남자입니다.");
                break;

            case '3':
                System.out.println("당신은 2000년 이후에 출생한 남자입니다.");
                break;
        }
        break; // 이 break문을 빼먹지 않도록 주의

    case '2': case '4':
        switch (gender) {
            case '2':
                System.out.println("당신은 2000년 이전에 출생한 여자입니다.");
                break;

            case '4':
                System.out.println("당긴은 2000년 이후에 출생한 여자입니다.");
                break;
        }

        break;

    default:
        System.out.println("유효하지 않는 주민등록번호입니다.");

}
```

<br>

<br>

<br>

## 2. 반복문 - for, while, do-while

---

### 1) for문

for문은 반복 횟수를 알고 있을 때 적합하다. 구조가 조금 복잡하지만 직관적이라 오히려 이해하기 쉽다.

아래의 for문은 블럭{} 내의 문장을 5번 반복한다.

```java
for (int i = 1; i <= 5; i++) {
		System.out.println("I can do it");
}

// i = 1  : 1부터
// i <= 5 : 5까지
// i++    : 1씩 증가
```

<br>

<br>

### for문의 구조와 수행순서

for문은 아래와 같이 '초기화', '조건식', '증감식', '블럭{}'. 모두 4부분으로 이루어져 있다.

```java
for (초기화; 조건식; 증감식) {
	// 조건식이 참일 때 수행될 문장들을 적는다.
}
```

<br>

<br>

### 초기화

반복문에 사용될 변수를 초기화하는 부분이며 처음에 한번만 수행된다. 보통 변수 하나로 for문을 제어하지만, 둘 이상의 변수가 필요할 때는 아래와 같이 `,` 를 구분자로 변수를 초기화한다.

```java
for (int i = 1; i < 10; i++) { ... }        // 변수 i의 값을 1로 초기화 한다.
for (int i = 1, j = 0; i < 10; i++) { ... } // int타입의 변수 i와 j를 선언하고 초기화
```

<br>

<br>

### 조건식

조건식의 값이 참(true)이면 반복을 계속하고, 거짓(false)이면 반복을 중단하고 for문을 벗어난다.

```java
for (int i = 1; i <= 10; i++) { ... } // 'i <= 10'가 참인 동안 블럭{}안의 문장들을 반복
```

조건식을 잘못 작성하면 블럭{} 내의 문장이 한 번도 수행되지 않거나 영원히 반복되는 무한반복에 빠지기 쉬우므로 주의해야 한다.

<br>

<br>

### 증감식

반복문을 제어하는 변수의 값을 증가 또는 감소시키는 식이다.

```java
for (int i = 1; i <= 10; i++)    { ... }  // 1부터 10까지 1씩 증가
for (int i = 10; i >= 1; j--)    { ... }  // 10부터 1까지 1식 감소
for (int i = 1; i <= 10; i += 2) { ... }  // 1부터 10까지 2씩 증가
for (int i = 1; i <= 10; i *= 3) { ... }  // 1부터 10까지 3배씩 증가
```

<br>

증감식도 쉼포 `,` 를 이용해서 두 문장 이상을 하나로 연결해서 쓸 수 있다.

```java
for (int i = 1, j = 10; i++, j--) {... } // i는 1부터 10까지 1씩 증가하고
                                         // j는 10부터 1까지 1씩 감소한다.
```

<br>

심지어 모두 생략하는 것도 가능하다.

```java
for(;;) { ... } // 초기화, 조건식, 증감식 모두 생략. 조건식은 참이 된다.
```

조건식이 생략된 경우, 참(true)으로 간주되어 무한 반복문이 된다. 대신 블럭{} 안에 if문을 넣어서 특정 조건을 만족하면 for문을 빠져 나오게 해야 한다.

<br>

<br>

### 중첩 for문

if문 안에 또 다른 if문을 넣을 수 있는 것처럼, for문 안에 또 다른 for문을 포함시키는 것도 가능하다.

그리고 중첩의 횟수는 거의 제한이 없다.

만일 다음과 같이 5행 10열의 별을 찍으려면 어떻게 해야 할까?

```java
**********
**********
**********
**********
**********
```

<br>

가장 간단한 방법은 다음과 같이 한 줄씩 5번 출력하는 것이다.

```java
System.out.println("**********");
System.out.println("**********");
System.out.println("**********");
System.out.println("**********");
System.out.println("**********");
```

<br>

그러나 우리는 for문을 배웠으니, 다음과 같이 간단히 할 수 있다.

```java
for (int i = 1; i <= 5; i++) {
		System.out.println("**********");
}
```

<br>

<br>

### 향상된 for문(enhanced for statement)

JDK1.5부터 배열과 컬렉션에 저장된 요소에 접근할 때 기존보다 편리한 방법으로 처리할 수 있도록 for문의 새로운 문법이 추가되었다.

```java
for (타입변수명 : 배열 또는 컬렉션) {
	// 반복할 문장
}
```

<br>

위의 문장에서 타입은 배열 또는 컬렉션의 요소의 타입이어야 한다. 배열 또는 컬렉션에 저장된 값이 매 반복마다 하나씩 순서대로 읽혀서 변수에 저장된다. 그리고 반복문의 괄호{}내에서는 이 변수를 사용해서 코드를 작성한다.

```java
int[] arr = {10, 20, 30, 40, 50};
```

<br>

배열 arr을 위와 같이 선언했을 때, 이 배열의 모든 요소를 출력하는 for문은 아래와 같다.

```java
for (int i = 0; i < arr.length; i++) {
		System.out.println(arr[i]);
}
```

```java
for (int tmp : arr) {
		System.out.println(tmp);
}
```

두 for문은 동등하며, 향상된 for문이 더 간결하다는 것을 알 수 있다. 그러나 향상된 for문은 일반적인 for문과 달리 배열이나 컬렉션에 저장된 요소들을 읽어오는 용도로만 사용할 수 있다는 제약이 있다.

<br>

<br>

### 2) while문

for문에 비해 while문은 구조가 간단하다. if문처럼 조건식과 블럭{}만으로 이루어져 있다.

다만 if문과 달리 while문은 조건식이 '참(true)인 동안', 즉 조건식이 거짓이 될 때까지 블럭{} 내의 문장을 반복한다.

```java
while (조건식) {
		// 조건식이 연산결과가 참(ture)인 동안, 반복될 문장들을 적는다.
}
```

1. 조건식이 참(true)이면 블럭{}안으로 들어가고, 거짓(false)이면 while문을 벗어난다.
2. 블럭{}의 문장을 수행하고 다시 조건식으로 돌아간다.

<br>

<br>

### for문과 while문의 비교

```java
// 초기화, 조건식, 증감식
for (int, i = 1; i <= 10; i++) {
		System.out.println(i);
}
```

```java
int i =1; // 초기화

while (i <= 10) { // 조건식
		System.out.println(i);
		i++; // 증감식
}
```

만일 초기화나 증감식이 필요하지 않는 경우라면, while문이 더 적합할 것이다.

<br>

### while문의 조건식은 생략불가

한 가지 주의할 점은 for문과 달리 while문의 조건식은 생략할 수 없다는 점이다.

```java
while() { // 에러. 조건식이 없음
		...
}
```

<br>

10부터 0까지 1씩 감소시켜가면서 출력을 하되, for문으로 매 출력마다 약간의 시간이 지연되도록 했다. 컴퓨터의 성능에 따라 지연되는 시간이 달라지므로 지연시간이 너무 짧거나 길면 반복횟수를 적절히 변경하자.

```java
for (int j = 0; j < 2_000_000_000; j++) {
    ;  // 아무런 내용도 없는 빈 문장
}
```

<br>

이 for문의 블럭{} 내에는 아무 일도 하지 않는 빈문장 `;` 하나만 있을 뿐 그 외에는 아무것도 없다.

블랙 내에 문장이 하나뿐일 때 괄호 {}를 생략할 수 있으므로 위의 for문을 바꿀 수 있다.

```java
for (int j = 0; j < 2_000_000_000; j++);
```

<br>

또는 아래와 같이 괄호{}를 써주고 빈 문장 `;` 을 없앨 수 있다.

```java
for (int j = 0; j < 2_000_000_000; j++) {}
```

<br>

간혹 실수로 다음과 같이 코드를 작성하는 경우가 있는데, 이럴 때는 빈 문장 `;` 만 for문에 속한 것으로 간주되어 블럭{}은 반복되지 않는다. 단 한번만 수행된다.

```java
for (i = 1; i <= 10; i++);           // 빈 문장 ';'을 10번 반복한다.
{
		System.out.println("i = " + i);  // i = 11이 출력된다.
}
```

<br>

<br>

### 3) do-while문

do-while문은 while문의 변형으로 기본적인 구조는 while문과 같으나 조건식과 블럭{}의 순서를 바꿔놓은 것이다. 그래서 while문과 반대로 블럭{}을 먼저 수행한 후에 조건식을 평가한다. while문은 조건식의 결과에 따라 블럭{}이 한 번도 수행되지 않을 수 있지만, do-while문은 최소한 한번은 수행될 것을 보장한다.

```java
do {
	// 조건식의 연산결과가 수행될 문장들을 적는다.
} while (조건식); // <- 끝에 ';'을 잊지 않도록 주의
```

그리 많이 쓰이지는 않지만, 다음의 예제처럼 반복적으로 사용자의 입력을 받아서 처리할 때 유용하다.

`Math.randon()` 을 이용해서 1과 100 사이의 임의의 수를 변수 answer에 저장하고, 이 값을 맞출 때까지 반복하는 예제이다. 사용자 입력인 input이 변수 answer의 값과 다른 동안 반복하다가 두 값이 같으면 반복을 벗어난다.

<br>

<br>

### 4) break문

주로 if문과 함께 사용되어 특정 조건을 만족하면 반복문을 벗어나도록 한다.

<br>

<br>

### 5) continue문

continue문은 반복문 내에서만 사용될 수 있으며, 반복이 진행되는 도중에 continue문을 만나면 반복문의 끝으로 이동하여 다음의 반복으로 넘어간다. for문의 경우 증감식으로 이동하며, while문과 do-while문의 경우 조건식으로 이동한다.

continue문은 반복문 전체를 벗어나지 않고 다음 반복을 계속 수행한다는 점이 break문과 다르다.

주로 if문과 함께 사용되어 특정 조건을 만족하는 경우에 continue문 이후의 문장들을 수행하지 않고 다음 반복으로 넘어가서 계속 진행하도록 한다.

전체 반복 중에 특정조건을 만족하는 경우를 제외하고자 할 떄 유용하다.

<br>

<br>

### 6) 이름 붙은 반복문

break문은 근접한 단 하나의 반복문만 벗어날 수 있기 때문에, 여러 개의 반복문이 중처보딘 경우에는 break문으로 중첩 반복문을 완전히 벗어날 수 없다. 이때는 중첩 반복문 앞에 이름을 붙이고 break문과 continue문에 이름을 지정해 줌으로써 하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있다.